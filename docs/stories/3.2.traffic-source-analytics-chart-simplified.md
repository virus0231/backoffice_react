# Story 3.2: Traffic Source Analytics Chart (Simplified)

## Status
Draft

## Story

**As a** digital marketing coordinator,
**I want** simplified traffic source analytics showing donation attribution across key channels,
**so that** I can identify the most effective donor acquisition channels for campaign optimization.

## Acceptance Criteria

1. Multi-line chart displaying donations by primary traffic sources (direct, social, email, organic search)
2. Each traffic source represented by distinct colored line with legend matching FundraisUP styling
3. Comparison overlay showing traffic source performance changes between time periods
4. Data table showing source-specific metrics: donation count, total raised, conversion rates
5. Integration with universal filter system for source analysis across specific appeals
6. User-provided query collaboration with agent optimization for traffic source attribution logic
7. Simplified implementation focusing on core channels (advanced device/payment analytics moved to Phase 2)

## Tasks / Subtasks

- [ ] Create TrafficSourceChart component (AC: 1)
  - [ ] Build TrafficSourceChart component in `apps/web/components/charts/TrafficSourceChart.tsx`
  - [ ] Implement Recharts multi-line chart with traffic source time-series data
  - [ ] Configure chart for primary sources: direct, social, email, organic search, referral
  - [ ] Add responsive chart layout optimizing source line readability
  - [ ] Style chart with distinct colors for each traffic source
  - [ ] Create chart loading skeleton and error states
- [ ] Implement traffic source line styling and legend (AC: 2)
  - [ ] Create traffic source color scheme mapping matching FundraisUP styling
  - [ ] Implement distinct line styles for each traffic source (solid, dashed, dotted)
  - [ ] Build interactive legend with source toggle functionality
  - [ ] Add traffic source icons/indicators in legend for visual clarity
  - [ ] Ensure accessibility compliance with color contrast requirements
  - [ ] Create responsive legend layout for mobile viewports
- [ ] Add comparison period overlay (AC: 3)
  - [ ] Integrate comparison system from Story 1.4 with traffic source chart
  - [ ] Implement dual-line visualization showing current vs. comparison period performance
  - [ ] Calculate traffic source performance changes and percentage deltas
  - [ ] Add visual indicators showing improved/declined source performance
  - [ ] Create comparison data overlay in chart tooltips
  - [ ] Include source ranking changes between periods
- [ ] Build traffic source data table (AC: 4)
  - [ ] Create TrafficSourceTable component in `apps/web/components/tables/TrafficSourceTable.tsx`
  - [ ] Implement columns: Source, Donation Count, Total Raised, Avg Gift, Conversion Rate
  - [ ] Add sortable functionality for all traffic source metrics
  - [ ] Include source performance ranking and percentage of total
  - [ ] Add comparison period data when overlay is active
  - [ ] Create traffic source trend indicators (up/down arrows with percentages)
- [ ] Integrate universal filter system (AC: 5)
  - [ ] Connect chart to global date range filtering for source analysis
  - [ ] Implement appeals filtering to analyze source performance by specific campaigns
  - [ ] Add funds filtering for traffic source effectiveness by fund category
  - [ ] Support frequency filtering for source analysis (one-time vs. recurring acquisition)
  - [ ] Ensure traffic source calculations respect all filter boundaries
  - [ ] Add real-time chart updates when filter selections change
- [ ] Establish traffic source query collaboration (AC: 6)
  - [ ] Create traffic source query request template with attribution requirements
  - [ ] Document traffic source field mapping and identification logic
  - [ ] Specify source aggregation needs and conversion rate calculations
  - [ ] Define expected performance parameters for traffic source queries
  - [ ] Create sample data output format for source attribution validation
  - [ ] Establish traffic source query optimization requirements
- [ ] Implement simplified core channel focus (AC: 7)
  - [ ] Focus implementation on essential traffic sources: direct, social, email, organic, referral
  - [ ] Create fallback category for "Other" sources not in core channels
  - [ ] Implement source classification logic for consistent attribution
  - [ ] Add source validation ensuring data quality and accurate attribution
  - [ ] Document limitations and Phase 2 expansion plans for advanced analytics
  - [ ] Create placeholder indicators for future advanced source analytics

## Dev Notes

### Previous Story Insights
**Story Dependencies:** This story builds on the campaign intelligence foundation from Story 3.1 and all previous foundation systems (Stories 1.1-2.4), completing the Phase 1 Campaign Intelligence epic.

### Technical Architecture Context
**Traffic Source Requirements:** [Source: docs/prd.md#functional-requirements]
- Traffic Source Analytics with multi-line chart showing donation attribution across different channels (FR16)
- Simplified implementation focusing on core channels with advanced device/payment analytics moved to Phase 2
- Integration with universal filter system for source analysis across specific appeals
- User-provided query collaboration with agent optimization for attribution logic

**Campaign Intelligence Context:** [Source: docs/prd.md#epic-3-campaign-intelligence]
- Essential attribution intelligence providing fundamental channel performance data
- Traffic source analytics for identifying most effective donor acquisition channels
- Part of Phase 1 core MVP completing campaign intelligence capabilities

### Database Query Logic Context
**Traffic Source Attribution Query Structure:**
```sql
-- Simplified traffic source attribution focusing on core channels
WITH traffic_source_mapping AS (
  SELECT
    t.id,
    t.donation_date,
    t.amount,
    t.member_id,
    t.appeal_id,
    t.fundlist_id,
    t.freq,
    t.status,
    CASE
      -- Core traffic source classification
      WHEN LOWER(COALESCE(t.referrer_source, t.utm_source, '')) LIKE '%email%' THEN 'email'
      WHEN LOWER(COALESCE(t.referrer_source, t.utm_source, '')) LIKE '%social%' THEN 'social'
      WHEN LOWER(COALESCE(t.referrer_source, t.utm_source, '')) LIKE '%facebook%' THEN 'social'
      WHEN LOWER(COALESCE(t.referrer_source, t.utm_source, '')) LIKE '%twitter%' THEN 'social'
      WHEN LOWER(COALESCE(t.referrer_source, t.utm_source, '')) LIKE '%linkedin%' THEN 'social'
      WHEN LOWER(COALESCE(t.referrer_source, t.utm_source, '')) LIKE '%google%' THEN 'organic'
      WHEN LOWER(COALESCE(t.referrer_source, t.utm_source, '')) LIKE '%search%' THEN 'organic'
      WHEN LOWER(COALESCE(t.referrer_source, t.utm_source, '')) = 'direct' THEN 'direct'
      WHEN COALESCE(t.referrer_source, t.utm_source, '') = '' THEN 'direct'
      WHEN t.referrer_source IS NOT NULL AND t.referrer_source != '' THEN 'referral'
      ELSE 'other'
    END as traffic_source
  FROM pw_transactions t
  WHERE t.status = 'completed'
    AND t.donation_date BETWEEN ? AND ?
    AND (t.appeal_id = ? OR ? IS NULL)
    AND (t.fundlist_id = ? OR ? IS NULL)
    AND (
      (? = 'all') OR
      (? = 'one-time' AND t.freq = 0) OR
      (? = 'recurring' AND t.freq > 0) OR
      (? = 'first-installments' AND t.freq = 1 AND t.order_id NOT REGEXP '_')
    )
),
source_performance AS (
  SELECT
    traffic_source,
    DATE(donation_date) as performance_date,
    COUNT(*) as donation_count,
    SUM(amount) as total_raised,
    AVG(amount) as average_donation,
    COUNT(DISTINCT member_id) as unique_donors
  FROM traffic_source_mapping
  GROUP BY traffic_source, DATE(donation_date)
),
source_conversion_rates AS (
  SELECT
    traffic_source,
    total_raised,
    donation_count,
    unique_donors,
    -- Simplified conversion rate calculation (donations per estimated visits)
    CASE
      WHEN traffic_source = 'email' THEN donation_count / GREATEST(unique_donors * 2, 1) -- Assume 2x email opens per donor
      WHEN traffic_source = 'social' THEN donation_count / GREATEST(unique_donors * 10, 1) -- Assume 10x social visits per donor
      WHEN traffic_source = 'organic' THEN donation_count / GREATEST(unique_donors * 5, 1) -- Assume 5x search visits per donor
      WHEN traffic_source = 'direct' THEN donation_count / GREATEST(unique_donors * 3, 1) -- Assume 3x direct visits per donor
      ELSE donation_count / GREATEST(unique_donors * 4, 1) -- Default assumption
    END as estimated_conversion_rate
  FROM (
    SELECT
      traffic_source,
      SUM(total_raised) as total_raised,
      SUM(donation_count) as donation_count,
      SUM(unique_donors) as unique_donors
    FROM source_performance
    GROUP BY traffic_source
  ) source_totals
)
SELECT
  sp.traffic_source,
  sp.performance_date,
  sp.donation_count,
  sp.total_raised,
  sp.average_donation,
  sp.unique_donors,
  scr.estimated_conversion_rate
FROM source_performance sp
LEFT JOIN source_conversion_rates scr ON sp.traffic_source = scr.traffic_source
ORDER BY sp.traffic_source, sp.performance_date;
```

**Note:** This simplified implementation assumes basic traffic source tracking. The query collaboration system will allow users to provide their specific traffic source attribution logic based on their actual data structure.

### API Integration Context
**Traffic Source Analytics API Endpoint:**
- `GET /api/v1/analytics/traffic-sources` - Simplified traffic source analytics

**API Response Structure:**
```typescript
interface TrafficSourceResponse {
  data: {
    sources: Array<{
      sourceName: 'direct' | 'social' | 'email' | 'organic' | 'referral' | 'other';
      displayName: string;
      currentPeriod: {
        totalRaised: number;
        donationCount: number;
        averageDonation: number;
        uniqueDonors: number;
        conversionRate: number;
        percentageOfTotal: number;
      };
      comparisonPeriod?: {
        totalRaised: number;
        donationCount: number;
        averageDonation: number;
        uniqueDonors: number;
        conversionRate: number;
      };
      timeSeriesData: Array<{
        date: string;
        donationCount: number;
        totalRaised: number;
        uniqueDonors: number;
      }>;
      performanceRanking: number; // 1-based ranking by total raised
      trend: {
        direction: 'up' | 'down' | 'flat';
        changePercentage: number;
      };
    }>;
    summary: {
      totalSources: number;
      topPerformingSource: {
        sourceName: string;
        totalRaised: number;
        percentageOfTotal: number;
      };
      sourceDistribution: {
        direct: number;
        social: number;
        email: number;
        organic: number;
        referral: number;
        other: number;
      };
      overallConversionRate: number;
    };
  };
  meta: {
    granularity: 'daily' | 'weekly' | 'monthly';
    simplified: true; // Indicates Phase 1 simplified implementation
    cached: boolean;
    lastUpdated: string;
  };
}
```

### Recharts Implementation Context
**Multi-Line Traffic Source Chart Configuration:**
```typescript
// Traffic source colors matching FundraisUP styling
const trafficSourceColors = {
  direct: '#3b82f6',      // Blue - Direct traffic
  social: '#ec4899',      // Pink - Social media
  email: '#10b981',       // Green - Email campaigns
  organic: '#f59e0b',     // Orange - Organic search
  referral: '#8b5cf6',    // Purple - Referral traffic
  other: '#6b7280'        // Gray - Other sources
};

const trafficSourceStyles = {
  direct: { strokeWidth: 2, strokeDasharray: '' },
  social: { strokeWidth: 2, strokeDasharray: '5 5' },
  email: { strokeWidth: 2, strokeDasharray: '10 5' },
  organic: { strokeWidth: 2, strokeDasharray: '15 5 5 5' },
  referral: { strokeWidth: 2, strokeDasharray: '20 5' },
  other: { strokeWidth: 1, strokeDasharray: '3 3' }
};

// Traffic source multi-line chart
<ResponsiveContainer width="100%" height={400}>
  <LineChart data={trafficSourceData} margin={{ top: 20, right: 30, left: 20, bottom: 20 }}>
    <CartesianGrid strokeDasharray="3 3" />
    <XAxis
      dataKey="date"
      tickFormatter={(date) => format(new Date(date), 'MMM dd')}
    />
    <YAxis
      tickFormatter={(value) => value.toLocaleString()}
    />
    <Tooltip content={<TrafficSourceTooltip />} />
    <Legend />

    {trafficSources.map(source => (
      <Line
        key={source}
        type="monotone"
        dataKey={`${source}_donations`}
        stroke={trafficSourceColors[source]}
        strokeWidth={trafficSourceStyles[source].strokeWidth}
        strokeDasharray={trafficSourceStyles[source].strokeDasharray}
        name={getDisplayName(source)}
        dot={{ r: 3, fill: trafficSourceColors[source] }}
        connectNulls={false}
      />
    ))}
  </LineChart>
</ResponsiveContainer>
```

**Custom Traffic Source Tooltip:**
```typescript
const TrafficSourceTooltip = ({ active, payload, label }: any) => {
  if (active && payload && payload.length) {
    const date = format(new Date(label), 'MMMM dd, yyyy');

    // Sort payload by value for better display
    const sortedPayload = [...payload].sort((a, b) => b.value - a.value);

    return (
      <div className="bg-white p-4 border border-gray-200 rounded-lg shadow-lg max-w-xs">
        <p className="font-semibold text-gray-800 mb-2">{date}</p>
        <div className="space-y-2">
          {sortedPayload.map((entry: any, index: number) => {
            const sourceName = entry.dataKey.replace('_donations', '');
            const displayName = getDisplayName(sourceName);

            return (
              <div key={index} className="flex items-center justify-between">
                <div className="flex items-center">
                  <div
                    className="w-3 h-3 rounded-full mr-2 flex-shrink-0"
                    style={{ backgroundColor: entry.color }}
                  />
                  <span className="text-sm font-medium">
                    {displayName}
                  </span>
                </div>
                <span className="text-sm font-semibold ml-2">
                  {entry.value.toLocaleString()}
                </span>
              </div>
            );
          })}
        </div>

        {/* Total and percentage breakdown */}
        <div className="mt-3 pt-2 border-t border-gray-100">
          <div className="text-xs text-gray-500">
            Total: {sortedPayload.reduce((sum, entry) => sum + entry.value, 0).toLocaleString()} donations
          </div>
          <div className="text-xs text-gray-500">
            Top source: {sortedPayload[0] ? getDisplayName(sortedPayload[0].dataKey.replace('_donations', '')) : 'N/A'}
          </div>
        </div>
      </div>
    );
  }
  return null;
};

const getDisplayName = (source: string): string => {
  const displayNames = {
    direct: 'Direct',
    social: 'Social Media',
    email: 'Email',
    organic: 'Organic Search',
    referral: 'Referrals',
    other: 'Other'
  };
  return displayNames[source] || source;
};
```

### Traffic Source Data Table Implementation
**Traffic Source Table Structure:**
```typescript
interface TrafficSourceTableRow {
  sourceName: string;
  displayName: string;
  donationCount: number;
  totalRaised: number;
  averageDonation: number;
  conversionRate: number;
  percentageOfTotal: number;
  trend: 'up' | 'down' | 'flat';
  changePercentage: number;
  ranking: number;
}

const TrafficSourceTableColumns = [
  {
    key: 'displayName',
    label: 'Source',
    sortable: true,
    cellRenderer: (row: TrafficSourceTableRow) => (
      <div className="flex items-center">
        <div
          className="w-3 h-3 rounded-full mr-2"
          style={{ backgroundColor: trafficSourceColors[row.sourceName] }}
        />
        <span className="font-medium">{row.displayName}</span>
      </div>
    )
  },
  {
    key: 'donationCount',
    label: 'Donations',
    sortable: true,
    formatter: (value: number) => value.toLocaleString()
  },
  {
    key: 'totalRaised',
    label: 'Total Raised',
    sortable: true,
    formatter: (value: number) => `$${value.toLocaleString()}`
  },
  {
    key: 'averageDonation',
    label: 'Avg. Gift',
    sortable: true,
    formatter: (value: number) => `$${value.toFixed(2)}`
  },
  {
    key: 'conversionRate',
    label: 'Conv. Rate',
    sortable: true,
    formatter: (value: number) => `${(value * 100).toFixed(2)}%`
  },
  {
    key: 'percentageOfTotal',
    label: '% of Total',
    sortable: true,
    formatter: (value: number) => `${value.toFixed(1)}%`,
    cellClassName: (value: number) =>
      value >= 30 ? 'text-green-600 font-semibold' :
      value >= 15 ? 'text-blue-600 font-semibold' :
      'text-gray-600'
  },
  {
    key: 'trend',
    label: 'Trend',
    sortable: false,
    cellRenderer: (row: TrafficSourceTableRow) => (
      <div className="flex items-center">
        {row.trend === 'up' && <span className="text-green-600">↗</span>}
        {row.trend === 'down' && <span className="text-red-600">↘</span>}
        {row.trend === 'flat' && <span className="text-gray-400">→</span>}
        <span className={`ml-1 text-xs ${
          row.trend === 'up' ? 'text-green-600' :
          row.trend === 'down' ? 'text-red-600' :
          'text-gray-400'
        }`}>
          {row.changePercentage > 0 ? '+' : ''}{row.changePercentage.toFixed(1)}%
        </span>
      </div>
    )
  }
];
```

### Traffic Source Classification Implementation
**Source Attribution Logic:**
```typescript
interface TrafficSourceClassifier {
  classifySource(referrerSource?: string, utmSource?: string, utmMedium?: string): TrafficSourceType;
}

export class TrafficSourceAnalytics implements TrafficSourceClassifier {
  private readonly sourcePatterns = {
    email: [
      /email/i,
      /newsletter/i,
      /mailchimp/i,
      /constant.?contact/i,
      /campaign.?monitor/i
    ],
    social: [
      /facebook/i,
      /twitter/i,
      /linkedin/i,
      /instagram/i,
      /youtube/i,
      /tiktok/i,
      /social/i
    ],
    organic: [
      /google/i,
      /bing/i,
      /yahoo/i,
      /search/i,
      /organic/i
    ],
    referral: [
      /\.edu$/i,
      /\.org$/i,
      /news/i,
      /blog/i
    ]
  };

  classifySource(
    referrerSource?: string,
    utmSource?: string,
    utmMedium?: string
  ): TrafficSourceType {
    const sourceText = [referrerSource, utmSource, utmMedium]
      .filter(Boolean)
      .join(' ')
      .toLowerCase();

    if (!sourceText || sourceText === 'direct') {
      return 'direct';
    }

    // Check against patterns
    for (const [sourceType, patterns] of Object.entries(this.sourcePatterns)) {
      if (patterns.some(pattern => pattern.test(sourceText))) {
        return sourceType as TrafficSourceType;
      }
    }

    // If referrer exists but doesn't match patterns, classify as referral
    if (referrerSource && referrerSource !== '') {
      return 'referral';
    }

    return 'other';
  }

  /**
   * Calculate simplified conversion rates for different sources
   */
  calculateConversionRate(
    sourceType: TrafficSourceType,
    donations: number,
    uniqueDonors: number
  ): number {
    // Simplified conversion rate estimation based on typical source behavior
    const estimatedVisitorMultipliers = {
      email: 2,    // Higher engagement, fewer visits per conversion
      direct: 3,   // Intentional visits, moderate conversion
      social: 10,  // Higher volume, lower conversion
      organic: 5,  // Searching with intent, moderate conversion
      referral: 4, // Recommended visits, good conversion
      other: 6     // Unknown source, conservative estimate
    };

    const multiplier = estimatedVisitorMultipliers[sourceType] || 6;
    const estimatedVisitors = Math.max(uniqueDonors * multiplier, donations);

    return donations / estimatedVisitors;
  }

  /**
   * Analyze source performance trends
   */
  analyzeSourceTrends(
    currentData: SourcePerformanceData[],
    comparisonData?: SourcePerformanceData[]
  ): SourceTrendAnalysis {
    const trends: Map<TrafficSourceType, SourceTrend> = new Map();

    currentData.forEach(current => {
      const comparison = comparisonData?.find(c => c.sourceName === current.sourceName);

      if (comparison) {
        const changePercentage = ((current.totalRaised - comparison.totalRaised) / comparison.totalRaised) * 100;

        trends.set(current.sourceName, {
          direction: Math.abs(changePercentage) < 5 ? 'flat' :
                   changePercentage > 0 ? 'up' : 'down',
          changePercentage: Math.round(changePercentage * 10) / 10,
          significance: Math.abs(changePercentage) > 20 ? 'high' : 'moderate'
        });
      } else {
        trends.set(current.sourceName, {
          direction: 'flat',
          changePercentage: 0,
          significance: 'none'
        });
      }
    });

    return {
      sourceTrends: trends,
      overallTrend: this.calculateOverallTrend(trends),
      recommendations: this.generateSourceRecommendations(trends, currentData)
    };
  }

  private generateSourceRecommendations(
    trends: Map<TrafficSourceType, SourceTrend>,
    currentData: SourcePerformanceData[]
  ): string[] {
    const recommendations: string[] = [];

    // Find top performing sources
    const topSource = currentData.reduce((top, current) =>
      current.totalRaised > top.totalRaised ? current : top
    );

    recommendations.push(`${getDisplayName(topSource.sourceName)} is your top performing source with $${topSource.totalRaised.toLocaleString()} raised`);

    // Identify declining sources that need attention
    trends.forEach((trend, sourceName) => {
      if (trend.direction === 'down' && trend.significance === 'high') {
        recommendations.push(`${getDisplayName(sourceName)} has declined by ${Math.abs(trend.changePercentage)}% - consider optimizing campaigns`);
      }
    });

    // Identify growing sources to invest more in
    trends.forEach((trend, sourceName) => {
      if (trend.direction === 'up' && trend.significance === 'high') {
        recommendations.push(`${getDisplayName(sourceName)} is growing by ${trend.changePercentage}% - consider increasing investment`);
      }
    });

    return recommendations;
  }
}

type TrafficSourceType = 'direct' | 'social' | 'email' | 'organic' | 'referral' | 'other';

interface SourceTrend {
  direction: 'up' | 'down' | 'flat';
  changePercentage: number;
  significance: 'high' | 'moderate' | 'none';
}
```

### Query Collaboration Context
**Traffic Source Query Request Template:**
```typescript
const trafficSourceQueryRequest: QueryCollaborationRequest = {
  chartType: 'traffic-source',
  requiredFields: [
    'pw_transactions.donation_date',
    'pw_transactions.amount',
    'pw_transactions.member_id',
    'pw_transactions.status',
    'pw_transactions.appeal_id',
    'pw_transactions.fundlist_id',
    'pw_transactions.freq',
    'traffic_source_field', // User to specify actual field name
    'utm_source_field',     // User to specify if available
    'referrer_field'        // User to specify if available
  ],
  timeFiltering: {
    dateRangeSupport: true,
    granularity: 'daily',
    comparisonPeriods: true
  },
  aggregationNeeds: [
    'COUNT(*) as donation_count by traffic_source and date',
    'SUM(amount) as total_raised by traffic_source and date',
    'AVG(amount) as average_donation by traffic_source',
    'COUNT(DISTINCT member_id) as unique_donors by traffic_source',
    'Traffic source classification logic',
    'Conversion rate estimation methodology'
  ],
  expectedPerformance: {
    maxExecutionTime: '800ms',
    expectedRowCount: 'variable based on date range and source diversity',
    indexingRequirements: [
      'INDEX on (traffic_source_field, donation_date, status)',
      'INDEX on (member_id, donation_date) for unique donor counting',
      'INDEX on (appeal_id, donation_date) for appeal filtering'
    ]
  },
  sampleDataFormat: {
    date: '2024-09-26',
    traffic_source: 'email',
    donation_count: 23,
    total_raised: 1840.50,
    unique_donors: 19,
    estimated_conversion_rate: 0.045
  },
  collaborationNotes: [
    'User needs to specify how traffic sources are tracked in their database',
    'May require custom logic for source classification based on available data',
    'Conversion rate calculation will be simplified without actual visitor data',
    'Phase 2 will expand to include advanced attribution and visitor tracking'
  ]
};
```

### File Locations and Naming Conventions
**Chart Component Files:**
- `apps/web/components/charts/TrafficSourceChart.tsx` - Main traffic source chart
- `apps/web/components/charts/TrafficSourceTooltip.tsx` - Custom tooltip component
- `apps/web/components/tables/TrafficSourceTable.tsx` - Traffic source data table

**API Route Files:**
- `apps/web/app/api/v1/analytics/traffic-sources/route.ts` - Traffic source analytics endpoint

**Analysis and Utility Files:**
- `apps/web/lib/analytics/TrafficSourceAnalytics.ts` - Source classification and analysis
- `apps/web/hooks/useTrafficSourceData.ts` - Data fetching hook
- `packages/shared/types/trafficSource.ts` - TypeScript interfaces

### Performance Optimization Context
**Simplified Source Analysis Caching:**
```typescript
// Traffic source data caching with source-specific TTL
const useTrafficSourceData = (filters: FilterState) => {
  return useQuery({
    queryKey: ['traffic-sources', filters],
    queryFn: async () => {
      const params = new URLSearchParams({
        startDate: filters.dateRange.startDate.toISOString(),
        endDate: filters.dateRange.endDate.toISOString(),
        granularity: 'daily',
        ...(filters.selectedAppeal && { appealId: filters.selectedAppeal.id }),
        ...(filters.selectedFund && { fundId: filters.selectedFund.id }),
        ...(filters.frequency !== 'all' && { frequency: filters.frequency })
      });

      const response = await fetch(`/api/v1/analytics/traffic-sources?${params}`);
      return response.json();
    },
    staleTime: 8 * 60 * 1000, // 8 minutes cache (source attribution can be complex)
    refetchOnWindowFocus: false,
  });
};
```

## Testing

### Testing Standards [Source: docs/architecture.md#technology-stack-table]
**Testing Framework:** Jest + React Testing Library for component testing
**Test File Location:** `__tests__/` directories alongside traffic source components
**Testing Patterns:**
- Component rendering tests for traffic source chart and table components
- Traffic source classification tests with various source attribution scenarios
- Multi-line chart visualization tests with proper color coding and legend functionality
- Filter integration tests ensuring proper source analysis across different campaigns

**Specific Testing Requirements for This Story:**
- Traffic source multi-line chart rendering with distinct colors and line styles
- Traffic source classification accuracy with various input scenarios
- Comparison period overlay functionality for source performance changes
- Data table rendering with source ranking and conversion rate calculations
- Universal filter integration for source analysis across appeals and date ranges
- Query collaboration system testing with mock user-provided source attribution logic
- Simplified implementation validation ensuring core channel focus

**Test Files to Create:**
- `apps/web/components/charts/__tests__/TrafficSourceChart.test.tsx` - Chart component tests
- `apps/web/components/tables/__tests__/TrafficSourceTable.test.tsx` - Table component tests
- `apps/web/lib/analytics/__tests__/TrafficSourceAnalytics.test.ts` - Classification and analysis tests
- `apps/web/hooks/__tests__/useTrafficSourceData.test.ts` - Data fetching hook tests
- `apps/web/__tests__/api/traffic-sources.test.ts` - API endpoint tests

## Change Log

| Date | Version | Description | Author |
|------|---------|-------------|---------|
| 2025-09-26 | 1.0 | Initial story creation with simplified traffic source analytics implementation for Phase 1 | Claude (Story Agent) |

## Dev Agent Record

*This section will be populated by the development agent during implementation*

### Agent Model Used
*To be filled by dev agent*

### Debug Log References
*To be filled by dev agent*

### Completion Notes List
*To be filled by dev agent*

### File List
*To be filled by dev agent*

## QA Results

*Results from QA Agent review will be populated here*