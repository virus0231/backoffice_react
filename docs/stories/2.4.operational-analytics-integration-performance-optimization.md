# Story 2.4: Operational Analytics Integration & Performance Optimization

## Status
Draft

## Story

**As a** system user,
**I want** all core analytics charts loading simultaneously with optimal performance,
**so that** I can analyze multiple metrics concurrently without delays or system slowdowns.

## Acceptance Criteria

1. Lazy loading implementation for chart components improving initial dashboard load
2. **Query collaboration system where development agent requests specific queries from user for each chart type**
3. **Agent optimization of user-provided queries for filtering, comparison periods, and performance**
4. Caching layer for frequently accessed analytics with appropriate TTL settings
5. Loading states and skeleton screens for all chart components
6. Error handling with user-friendly messages for data loading failures
7. Performance monitoring ensuring sub-3-second load times for all four charts
8. Responsive behavior maintaining chart readability across device sizes

## Tasks / Subtasks

- [ ] Implement lazy loading for operational analytics charts (AC: 1)
  - [ ] Configure dynamic imports for chart components using Next.js lazy loading
  - [ ] Create chart container wrapper with intersection observer for viewport-based loading
  - [ ] Implement progressive chart loading prioritizing above-the-fold content
  - [ ] Add preloading hints for charts likely to be viewed next
  - [ ] Optimize bundle splitting to reduce initial JavaScript payload
  - [ ] Test lazy loading performance across different network conditions
- [ ] Establish query collaboration system (AC: 2)
  - [ ] Create query request templates for each operational analytics chart
  - [ ] Document required data fields, time filtering, and aggregation needs for donations count analytics
  - [ ] Document donor retention query requirements with cohort analysis specifications
  - [ ] Document first-time donor identification query with historical lookback requirements
  - [ ] Create sample data output specifications for validation
  - [ ] Establish query performance parameters and expected row counts for each chart
- [ ] Implement agent query optimization process (AC: 3)
  - [ ] Create Sequelize ORM implementations for user-provided base queries
  - [ ] Integrate universal filtering (date, appeals, funds, frequency) into optimized queries
  - [ ] Add comparison period calculations to all operational analytics queries
  - [ ] Implement connection pooling alignment for concurrent query execution
  - [ ] Create query validation and error handling for malformed user inputs
  - [ ] Add query performance monitoring and optimization recommendations
- [ ] Build comprehensive caching layer (AC: 4)
  - [ ] Implement Redis-compatible in-memory caching for operational analytics data
  - [ ] Set appropriate TTL settings: 5 minutes for real-time metrics, 1 hour for historical data
  - [ ] Create cache invalidation logic for filter changes and data updates
  - [ ] Add cache warming for frequently accessed operational analytics
  - [ ] Implement cache hit/miss monitoring and optimization
  - [ ] Create cache fallback strategies for cache failures
- [ ] Create loading states and skeleton screens (AC: 5)
  - [ ] Build skeleton components matching each chart's layout and dimensions
  - [ ] Implement coordinated loading states across all operational analytics charts
  - [ ] Add loading progress indicators for data-intensive charts
  - [ ] Create smooth transitions between loading and loaded states
  - [ ] Ensure skeleton screens maintain proper responsive behavior
  - [ ] Add loading time estimates for user feedback
- [ ] Implement comprehensive error handling (AC: 6)
  - [ ] Create error boundary components for each operational analytics chart
  - [ ] Implement user-friendly error messages for common failure scenarios
  - [ ] Add retry mechanisms with exponential backoff for transient failures
  - [ ] Create error reporting system for operational analytics issues
  - [ ] Implement graceful degradation when individual charts fail
  - [ ] Add error recovery options and user guidance
- [ ] Add performance monitoring and optimization (AC: 7)
  - [ ] Implement client-side performance monitoring for chart load times
  - [ ] Create performance budgets ensuring sub-3-second load times
  - [ ] Add database query performance monitoring for operational analytics
  - [ ] Implement performance alerts for degradation detection
  - [ ] Create performance optimization recommendations system
  - [ ] Add performance metrics dashboard for system monitoring
- [ ] Ensure responsive behavior across device sizes (AC: 8)
  - [ ] Test operational analytics charts on mobile, tablet, and desktop viewports
  - [ ] Implement responsive chart sizing maintaining readability
  - [ ] Optimize touch interactions for mobile operational analytics usage
  - [ ] Ensure data table functionality works across all device sizes
  - [ ] Add responsive navigation for chart switching on mobile
  - [ ] Test performance on various device capabilities and network speeds

## Dev Notes

### Previous Story Insights
**Story Dependencies:** This story serves as the integration and optimization capstone for all operational analytics charts (Stories 2.1-2.3), building on the foundation systems (Stories 1.1-1.5) and ensuring optimal performance for the complete Phase 1 implementation.

### Technical Architecture Context
**Performance Requirements:** [Source: docs/prd.md#non-functional-requirements]
- Dashboard load times must be under 3 seconds for all visualizations (NFR1)
- Support concurrent usage by multiple users without performance degradation (NFR6)
- Handle complex analytical queries without impacting operational systems performance (NFR3)
- Optimized database connection pooling for handling multiple simultaneous chart data requests (NFR7)

**Query Collaboration Process:** [Source: docs/prd.md#query-collaboration-process]
1. Agent identifies specific data fields, time filtering, aggregation needs for each chart
2. User provides base SQL working with existing phpMySQL database
3. Agent optimization process: Sequelize ORM implementation with universal filtering
4. Validation cycle ensuring data accuracy and performance requirements

### Performance Optimization Strategy
**Multi-Level Caching Architecture:** [Source: docs/prd.md#technical-assumptions]
```typescript
interface CachingStrategy {
  // Level 1: Browser cache for static assets and chart configurations
  browserCache: {
    chartComponents: '1 hour',
    staticAssets: '24 hours'
  };

  // Level 2: Application cache for frequently accessed data
  applicationCache: {
    realTimeMetrics: '5 minutes',
    historicalData: '1 hour',
    filterOptions: '6 hours'
  };

  // Level 3: Database query result cache
  queryCache: {
    aggregatedAnalytics: '10 minutes',
    complexCalculations: '30 minutes',
    donorRetentionData: '1 hour'
  };
}
```

**Lazy Loading Implementation:**
```typescript
// Progressive chart loading with intersection observer
const OperationalAnalyticsSection = () => {
  const [visibleCharts, setVisibleCharts] = useState<string[]>([]);

  const chartObserver = useCallback((entries: IntersectionObserverEntry[]) => {
    entries.forEach((entry) => {
      if (entry.isIntersecting) {
        const chartId = entry.target.getAttribute('data-chart-id');
        if (chartId && !visibleCharts.includes(chartId)) {
          setVisibleCharts(prev => [...prev, chartId]);
        }
      }
    });
  }, [visibleCharts]);

  useEffect(() => {
    const observer = new IntersectionObserver(chartObserver, {
      rootMargin: '100px' // Load charts 100px before they come into view
    });

    document.querySelectorAll('[data-chart-id]').forEach((el) => {
      observer.observe(el);
    });

    return () => observer.disconnect();
  }, [chartObserver]);

  return (
    <div className="grid gap-6">
      <ChartContainer chartId="donations-count">
        {visibleCharts.includes('donations-count') ? (
          <DonationsCountChart />
        ) : (
          <ChartSkeleton />
        )}
      </ChartContainer>

      <ChartContainer chartId="donor-retention">
        {visibleCharts.includes('donor-retention') ? (
          <DonorRetentionChart />
        ) : (
          <ChartSkeleton />
        )}
      </ChartContainer>

      <ChartContainer chartId="first-time-donors">
        {visibleCharts.includes('first-time-donors') ? (
          <FirstTimeDonorsChart />
        ) : (
          <ChartSkeleton />
        )}
      </ChartContainer>
    </div>
  );
};
```

### Query Collaboration Implementation
**Query Request Template System:**
```typescript
interface QueryCollaborationRequest {
  chartType: 'donations-count' | 'donor-retention' | 'first-time-donors';
  requiredFields: string[];
  timeFiltering: {
    dateRangeSupport: boolean;
    granularity: 'daily' | 'weekly' | 'monthly';
    comparisonPeriods: boolean;
  };
  aggregationNeeds: string[];
  expectedPerformance: {
    maxExecutionTime: string;
    expectedRowCount: number;
    indexingRequirements: string[];
  };
  sampleDataFormat: object;
}

// Example query request for donations count analytics
const donationsCountQueryRequest: QueryCollaborationRequest = {
  chartType: 'donations-count',
  requiredFields: [
    'pw_transactions.donation_date',
    'pw_transactions.amount',
    'pw_transactions.status',
    'pw_transactions.appeal_id',
    'pw_transactions.fundlist_id',
    'pw_transactions.freq'
  ],
  timeFiltering: {
    dateRangeSupport: true,
    granularity: 'daily',
    comparisonPeriods: true
  },
  aggregationNeeds: [
    'COUNT(*) as donation_count',
    'SUM(amount) as total_amount',
    'AVG(amount) as average_amount',
    'DATE(donation_date) as date_group'
  ],
  expectedPerformance: {
    maxExecutionTime: '500ms',
    expectedRowCount: 365, // One year of daily data
    indexingRequirements: [
      'INDEX on (donation_date, status)',
      'INDEX on (appeal_id, donation_date)',
      'INDEX on (fundlist_id, donation_date)'
    ]
  },
  sampleDataFormat: {
    date: '2024-09-26',
    donation_count: 45,
    total_amount: 5420.50,
    average_amount: 120.46
  }
};
```

### Caching Implementation Context
**Comprehensive Caching System:**
```typescript
// Multi-level caching implementation
class OperationalAnalyticsCache {
  private memoryCache = new Map<string, CacheEntry>();
  private redisClient?: Redis;

  async get<T>(key: string, fetcher: () => Promise<T>, ttl: number): Promise<T> {
    // Level 1: Memory cache check
    const memoryEntry = this.memoryCache.get(key);
    if (memoryEntry && !this.isExpired(memoryEntry)) {
      return memoryEntry.data as T;
    }

    // Level 2: Redis cache check (if available)
    if (this.redisClient) {
      const redisData = await this.redisClient.get(key);
      if (redisData) {
        const parsedData = JSON.parse(redisData) as T;
        this.setMemoryCache(key, parsedData, ttl);
        return parsedData;
      }
    }

    // Level 3: Fetch from database
    const freshData = await fetcher();

    // Cache at all levels
    await this.setAllLevels(key, freshData, ttl);

    return freshData;
  }

  private async setAllLevels<T>(key: string, data: T, ttl: number): Promise<void> {
    // Memory cache
    this.setMemoryCache(key, data, ttl);

    // Redis cache
    if (this.redisClient) {
      await this.redisClient.setex(key, ttl, JSON.stringify(data));
    }
  }

  // Cache invalidation for filter changes
  async invalidatePattern(pattern: string): Promise<void> {
    // Clear memory cache entries matching pattern
    for (const [key] of this.memoryCache) {
      if (key.includes(pattern)) {
        this.memoryCache.delete(key);
      }
    }

    // Clear Redis entries
    if (this.redisClient) {
      const keys = await this.redisClient.keys(`*${pattern}*`);
      if (keys.length > 0) {
        await this.redisClient.del(...keys);
      }
    }
  }
}
```

### Performance Monitoring Implementation
**Client-Side Performance Tracking:**
```typescript
interface PerformanceMetrics {
  chartId: string;
  loadStartTime: number;
  dataFetchTime: number;
  renderTime: number;
  totalLoadTime: number;
  cacheHit: boolean;
}

class PerformanceMonitor {
  private metrics: PerformanceMetrics[] = [];

  startCharting(chartId: string): PerformanceTracker {
    const startTime = performance.now();

    return {
      markDataFetched: () => {
        const dataFetchTime = performance.now() - startTime;
        return {
          markRendered: (cacheHit: boolean = false) => {
            const totalTime = performance.now() - startTime;
            const renderTime = totalTime - dataFetchTime;

            const metric: PerformanceMetrics = {
              chartId,
              loadStartTime: startTime,
              dataFetchTime,
              renderTime,
              totalLoadTime: totalTime,
              cacheHit
            };

            this.metrics.push(metric);
            this.checkPerformanceBudget(metric);
          }
        };
      }
    };
  }

  private checkPerformanceBudget(metric: PerformanceMetrics): void {
    const PERFORMANCE_BUDGET = 3000; // 3 seconds

    if (metric.totalLoadTime > PERFORMANCE_BUDGET) {
      console.warn(`Performance budget exceeded for ${metric.chartId}: ${metric.totalLoadTime}ms`);

      // Send performance alert
      this.sendPerformanceAlert(metric);
    }
  }

  getPerformanceReport(): PerformanceSummary {
    return {
      averageLoadTime: this.metrics.reduce((sum, m) => sum + m.totalLoadTime, 0) / this.metrics.length,
      cacheHitRate: (this.metrics.filter(m => m.cacheHit).length / this.metrics.length) * 100,
      slowestChart: this.metrics.reduce((slowest, current) =>
        current.totalLoadTime > slowest.totalLoadTime ? current : slowest
      ),
      budgetViolations: this.metrics.filter(m => m.totalLoadTime > 3000).length
    };
  }
}
```

### Error Handling and Recovery
**Comprehensive Error Boundary System:**
```typescript
interface ErrorInfo {
  chartId: string;
  errorType: 'network' | 'parsing' | 'rendering' | 'query';
  errorMessage: string;
  recoverable: boolean;
  retryCount: number;
}

class OperationalAnalyticsErrorBoundary extends React.Component<
  { children: React.ReactNode; chartId: string },
  { hasError: boolean; errorInfo: ErrorInfo | null }
> {
  constructor(props: any) {
    super(props);
    this.state = { hasError: false, errorInfo: null };
  }

  static getDerivedStateFromError(error: Error, errorInfo: React.ErrorInfo) {
    return {
      hasError: true,
      errorInfo: {
        chartId: this.props.chartId,
        errorType: this.classifyError(error),
        errorMessage: error.message,
        recoverable: this.isRecoverable(error),
        retryCount: 0
      }
    };
  }

  private static classifyError(error: Error): ErrorInfo['errorType'] {
    if (error.message.includes('fetch')) return 'network';
    if (error.message.includes('JSON')) return 'parsing';
    if (error.message.includes('query')) return 'query';
    return 'rendering';
  }

  handleRetry = async () => {
    if (this.state.errorInfo && this.state.errorInfo.recoverable) {
      this.setState(prevState => ({
        hasError: false,
        errorInfo: prevState.errorInfo ? {
          ...prevState.errorInfo,
          retryCount: prevState.errorInfo.retryCount + 1
        } : null
      }));
    }
  };

  render() {
    if (this.state.hasError && this.state.errorInfo) {
      return (
        <div className="bg-red-50 border border-red-200 rounded-lg p-6">
          <div className="flex">
            <div className="ml-3">
              <h3 className="text-sm font-medium text-red-800">
                Chart Loading Error
              </h3>
              <div className="mt-2 text-sm text-red-700">
                <p>{this.getFriendlyErrorMessage(this.state.errorInfo)}</p>
              </div>
              {this.state.errorInfo.recoverable && (
                <div className="mt-4">
                  <button
                    onClick={this.handleRetry}
                    className="bg-red-100 px-3 py-2 rounded text-sm text-red-800 hover:bg-red-200"
                  >
                    Retry Loading Chart
                  </button>
                </div>
              )}
            </div>
          </div>
        </div>
      );
    }

    return this.props.children;
  }

  private getFriendlyErrorMessage(errorInfo: ErrorInfo): string {
    const messages = {
      network: 'Unable to load chart data. Please check your connection and try again.',
      parsing: 'There was an issue processing the chart data. Our team has been notified.',
      rendering: 'The chart could not be displayed properly. Try refreshing the page.',
      query: 'There was an issue with the data query. Please adjust your filters or try again.'
    };

    return messages[errorInfo.errorType] || 'An unexpected error occurred while loading the chart.';
  }
}
```

### Responsive Behavior Implementation
**Cross-Device Optimization:**
```typescript
// Responsive chart configuration hook
const useResponsiveChartConfig = () => {
  const [screenSize, setScreenSize] = useState<'mobile' | 'tablet' | 'desktop'>('desktop');

  useEffect(() => {
    const updateScreenSize = () => {
      if (window.innerWidth < 768) {
        setScreenSize('mobile');
      } else if (window.innerWidth < 1024) {
        setScreenSize('tablet');
      } else {
        setScreenSize('desktop');
      }
    };

    updateScreenSize();
    window.addEventListener('resize', updateScreenSize);
    return () => window.removeEventListener('resize', updateScreenSize);
  }, []);

  const chartConfig = useMemo(() => {
    const configs = {
      mobile: {
        height: 250,
        margin: { top: 10, right: 10, left: 10, bottom: 10 },
        fontSize: 12,
        tickCount: 4,
        showLegend: false
      },
      tablet: {
        height: 300,
        margin: { top: 15, right: 20, left: 15, bottom: 15 },
        fontSize: 13,
        tickCount: 6,
        showLegend: true
      },
      desktop: {
        height: 400,
        margin: { top: 20, right: 30, left: 20, bottom: 20 },
        fontSize: 14,
        tickCount: 8,
        showLegend: true
      }
    };

    return configs[screenSize];
  }, [screenSize]);

  return { screenSize, chartConfig };
};
```

### File Locations and Naming Conventions
**Integration Component Files:**
- `apps/web/components/analytics/OperationalAnalyticsSection.tsx` - Main integration container
- `apps/web/components/charts/ChartContainer.tsx` - Lazy loading chart wrapper
- `apps/web/components/charts/ChartSkeleton.tsx` - Loading skeleton component
- `apps/web/components/error/OperationalAnalyticsErrorBoundary.tsx` - Error handling

**Performance and Caching Files:**
- `apps/web/lib/cache/OperationalAnalyticsCache.ts` - Multi-level caching system
- `apps/web/lib/performance/PerformanceMonitor.ts` - Client-side performance tracking
- `apps/web/hooks/useResponsiveChartConfig.ts` - Responsive configuration hook

**Query Collaboration Files:**
- `apps/web/lib/queries/QueryCollaborationTemplates.ts` - Query request templates
- `apps/web/lib/optimization/QueryOptimizer.ts` - Agent query optimization utilities
- `docs/query-collaboration-guidelines.md` - Collaboration process documentation

### Integration Testing Strategy
**Performance and Load Testing:**
```typescript
// Performance testing utilities
export const performanceTestSuite = {
  async testChartLoadTimes(chartIds: string[]): Promise<PerformanceReport> {
    const results: PerformanceMetrics[] = [];

    for (const chartId of chartIds) {
      const startTime = performance.now();

      // Simulate chart loading
      await this.loadChart(chartId);

      const endTime = performance.now();
      results.push({
        chartId,
        loadTime: endTime - startTime,
        withinBudget: (endTime - startTime) < 3000
      });
    }

    return {
      results,
      averageLoadTime: results.reduce((sum, r) => sum + r.loadTime, 0) / results.length,
      budgetViolations: results.filter(r => !r.withinBudget).length
    };
  },

  async testConcurrentUsers(userCount: number): Promise<ConcurrencyReport> {
    const promises = Array.from({ length: userCount }, () =>
      this.simulateUserSession()
    );

    const sessionResults = await Promise.all(promises);

    return {
      totalUsers: userCount,
      successfulSessions: sessionResults.filter(r => r.success).length,
      averageResponseTime: sessionResults.reduce((sum, r) => sum + r.responseTime, 0) / sessionResults.length,
      performanceDegradation: this.calculateDegradation(sessionResults)
    };
  }
};
```

## Testing

### Testing Standards [Source: docs/architecture.md#technology-stack-table]
**Testing Framework:** Jest + React Testing Library for component testing, Playwright for E2E performance testing
**Test File Location:** `__tests__/` directories alongside integration components
**Testing Patterns:**
- Performance testing for chart loading times and concurrent usage
- Integration testing for query collaboration and optimization systems
- Caching layer testing with cache hit/miss scenarios
- Error handling testing with various failure conditions

**Specific Testing Requirements for This Story:**
- Lazy loading implementation testing with intersection observer simulation
- Query collaboration system testing with mock user-provided queries
- Agent optimization testing ensuring improved query performance
- Multi-level caching system testing with TTL and invalidation scenarios
- Loading state coordination testing across all operational analytics charts
- Error boundary testing with various error types and recovery scenarios
- Performance monitoring testing ensuring sub-3-second load times
- Responsive behavior testing across mobile, tablet, and desktop viewports

**Test Files to Create:**
- `apps/web/components/analytics/__tests__/OperationalAnalyticsSection.test.tsx` - Integration tests
- `apps/web/lib/cache/__tests__/OperationalAnalyticsCache.test.ts` - Caching system tests
- `apps/web/lib/performance/__tests__/PerformanceMonitor.test.ts` - Performance monitoring tests
- `apps/web/lib/queries/__tests__/QueryOptimizer.test.ts` - Query optimization tests
- `apps/web/__tests__/performance/operational-analytics-performance.test.ts` - E2E performance tests

## Change Log

| Date | Version | Description | Author |
|------|---------|-------------|---------|
| 2025-09-26 | 1.0 | Initial story creation with comprehensive operational analytics integration and performance optimization | Claude (Story Agent) |

## Dev Agent Record

*This section will be populated by the development agent during implementation*

### Agent Model Used
*To be filled by dev agent*

### Debug Log References
*To be filled by dev agent*

### Completion Notes List
*To be filled by dev agent*

### File List
*To be filled by dev agent*

## QA Results

*Results from QA Agent review will be populated here*