# Story 3.1: Campaign Performance Analytics Chart

## Status
Draft

## Story

**As a** campaign manager,
**I want** campaign-by-campaign performance tracking with trend visualization,
**so that** I can compare campaign effectiveness and optimize ongoing fundraising initiatives.

## Acceptance Criteria

1. Multi-line chart showing performance trends for different campaigns/appeals over time
2. Campaign selection interface allowing users to choose which campaigns to display and compare
3. Performance metrics including donation volume, revenue, donor acquisition, and retention rates
4. Comparison period functionality showing campaign performance changes
5. Data table with detailed campaign metrics and ROI calculations
6. Filter integration for campaign-specific analysis by date ranges and donor segments
7. Query collaboration system where development agent requests specific campaign queries

## Tasks / Subtasks

- [ ] Create CampaignPerformanceChart component (AC: 1)
  - [ ] Build CampaignPerformanceChart component in `apps/web/components/charts/CampaignPerformanceChart.tsx`
  - [ ] Implement Recharts multi-line chart with campaign performance time-series data
  - [ ] Configure chart with multiple Y-axis scales for different metrics (revenue, donor count)
  - [ ] Add distinct color coding for each campaign line with accessible color palette
  - [ ] Create responsive chart layout optimizing multi-line readability
  - [ ] Implement chart legend with campaign identification and toggle functionality
- [ ] Build campaign selection interface (AC: 2)
  - [ ] Create CampaignSelector component in `apps/web/components/filters/CampaignSelector.tsx`
  - [ ] Implement multi-select dropdown with search functionality for campaign names
  - [ ] Add campaign status indicators (active, paused, completed) in selection interface
  - [ ] Create "Select All Active Campaigns" and "Clear Selection" quick actions
  - [ ] Implement campaign comparison limits (max 5-7 campaigns) for chart readability
  - [ ] Add selected campaign badges with individual remove functionality
- [ ] Implement comprehensive performance metrics (AC: 3)
  - [ ] Create campaign metrics calculations in `apps/web/lib/calculations/campaignPerformanceCalculations.ts`
  - [ ] Implement donation volume tracking per campaign over time periods
  - [ ] Calculate campaign revenue with proper attribution to appeals/funds
  - [ ] Add donor acquisition metrics: new donors per campaign, acquisition cost
  - [ ] Implement campaign-specific retention rates and repeat donor analysis
  - [ ] Create ROI calculations including campaign costs (when available) vs. revenue
- [ ] Add comparison period functionality (AC: 4)
  - [ ] Integrate comparison system from Story 1.4 with campaign performance chart
  - [ ] Implement dual-period comparison showing campaign performance changes
  - [ ] Calculate campaign performance deltas between current and comparison periods
  - [ ] Add percentage change indicators for each campaign metric
  - [ ] Create visual indicators showing improved/declined campaign performance
  - [ ] Include comparison period data in campaign performance tooltips
- [ ] Build campaign performance data table (AC: 5)
  - [ ] Create CampaignPerformanceTable component in `apps/web/components/tables/CampaignPerformanceTable.tsx`
  - [ ] Implement columns: Campaign Name, Total Raised, Donor Count, Avg Gift, New Donors, ROI
  - [ ] Add sortable functionality for all performance metrics
  - [ ] Include campaign status and date range information
  - [ ] Add comparison period data when overlay is active
  - [ ] Create campaign ranking based on selected performance metric
- [ ] Integrate universal filter system (AC: 6)
  - [ ] Connect chart to global date range filtering for campaign analysis
  - [ ] Implement funds filtering to analyze campaign performance by fund allocation
  - [ ] Add frequency filtering for campaign performance analysis (recurring vs. one-time focus)
  - [ ] Support donor segment filtering for campaign effectiveness by donor type
  - [ ] Ensure campaign performance calculations respect all filter boundaries
  - [ ] Add real-time chart updates when filter selections change
- [ ] Establish campaign query collaboration system (AC: 7)
  - [ ] Create campaign performance query request template with required data fields
  - [ ] Document campaign attribution logic: appeal_id mapping to performance metrics
  - [ ] Specify campaign aggregation needs: time-based grouping, metric calculations
  - [ ] Define expected performance parameters for campaign queries
  - [ ] Create sample data output format for campaign performance validation
  - [ ] Establish campaign query optimization requirements with user collaboration

## Dev Notes

### Previous Story Insights
**Story Dependencies:** This story builds on all foundation systems (Stories 1.1-1.5) and operational analytics patterns (Stories 2.1-2.4), marking the beginning of Epic 3: Campaign Intelligence implementation.

### Technical Architecture Context
**Campaign Performance Requirements:** [Source: docs/prd.md#functional-requirements]
- Campaign Performance tracking with multi-line visualization comparing effectiveness (FR17)
- Campaign selection interface for choosing campaigns to display and compare
- Performance metrics including donation volume, revenue, donor acquisition, retention rates
- Integration with universal filter system for campaign-specific analysis

**Campaign Intelligence Context:** [Source: docs/prd.md#epic-3-campaign-intelligence]
- Essential campaign effectiveness insights and fundamental attribution data
- Campaign performance tracking for daily campaign optimization and resource allocation decisions
- Part of Phase 1 core MVP providing immediate campaign management value

### Database Query Logic Context
**Campaign Performance Query Structure:**
```sql
-- Comprehensive campaign performance analysis
WITH campaign_performance AS (
  SELECT
    a.id as campaign_id,
    a.appeal_name as campaign_name,
    a.status as campaign_status,
    a.start_date,
    a.end_date,
    a.goal_amount,
    DATE(t.donation_date) as performance_date,
    COUNT(DISTINCT t.id) as donation_count,
    SUM(t.amount) as total_raised,
    AVG(t.amount) as average_donation,
    COUNT(DISTINCT t.member_id) as total_donors,
    COUNT(DISTINCT CASE
      WHEN first_donations.first_donation_date = t.donation_date
      THEN t.member_id
    END) as new_donors
  FROM pw_appeal a
  JOIN pw_transactions t ON a.id = t.appeal_id
  LEFT JOIN (
    SELECT member_id, MIN(donation_date) as first_donation_date
    FROM pw_transactions
    WHERE status = 'completed'
    GROUP BY member_id
  ) first_donations ON t.member_id = first_donations.member_id
  WHERE t.status = 'completed'
    AND t.donation_date BETWEEN ? AND ?
    AND (t.fundlist_id = ? OR ? IS NULL)
    AND (
      (? = 'all') OR
      (? = 'one-time' AND t.freq = 0) OR
      (? = 'recurring' AND t.freq > 0) OR
      (? = 'first-installments' AND t.freq = 1 AND t.order_id NOT REGEXP '_')
    )
    AND a.id IN (?) -- Selected campaigns
  GROUP BY a.id, a.appeal_name, a.status, a.start_date, a.end_date, a.goal_amount, DATE(t.donation_date)
),
campaign_retention AS (
  SELECT
    campaign_id,
    COUNT(DISTINCT CASE WHEN repeat_donor = 1 THEN donor_id END) as repeat_donors,
    COUNT(DISTINCT donor_id) as total_unique_donors
  FROM (
    SELECT
      t1.appeal_id as campaign_id,
      t1.member_id as donor_id,
      CASE WHEN t2.member_id IS NOT NULL THEN 1 ELSE 0 END as repeat_donor
    FROM pw_transactions t1
    LEFT JOIN pw_transactions t2
      ON t1.member_id = t2.member_id
      AND t2.donation_date < t1.donation_date
      AND t2.status = 'completed'
    WHERE t1.status = 'completed'
      AND t1.donation_date BETWEEN ? AND ?
      AND t1.appeal_id IN (?)
  ) donor_analysis
  GROUP BY campaign_id
)
SELECT
  cp.campaign_id,
  cp.campaign_name,
  cp.campaign_status,
  cp.performance_date,
  cp.donation_count,
  cp.total_raised,
  cp.average_donation,
  cp.total_donors,
  cp.new_donors,
  cp.goal_amount,
  CASE
    WHEN cp.goal_amount > 0
    THEN (SUM(cp.total_raised) OVER (PARTITION BY cp.campaign_id) / cp.goal_amount) * 100
    ELSE NULL
  END as goal_progress_percentage,
  cr.repeat_donors,
  CASE
    WHEN cr.total_unique_donors > 0
    THEN (cr.repeat_donors / cr.total_unique_donors) * 100
    ELSE 0
  END as retention_rate_percentage
FROM campaign_performance cp
LEFT JOIN campaign_retention cr ON cp.campaign_id = cr.campaign_id
ORDER BY cp.campaign_id, cp.performance_date;
```

**ROI Calculation Logic:**
```sql
-- Campaign ROI calculation when cost data is available
SELECT
  campaign_id,
  campaign_name,
  total_raised,
  COALESCE(campaign_cost, 0) as campaign_cost,
  CASE
    WHEN COALESCE(campaign_cost, 0) > 0
    THEN ((total_raised - campaign_cost) / campaign_cost) * 100
    ELSE NULL
  END as roi_percentage,
  CASE
    WHEN COALESCE(campaign_cost, 0) > 0
    THEN total_raised / campaign_cost
    ELSE NULL
  END as return_multiple
FROM campaign_summary
WHERE campaign_cost IS NOT NULL;
```

### API Integration Context
**Campaign Performance API Endpoint:**
- `GET /api/v1/analytics/campaign-performance` - Campaign analytics with multi-campaign support

**API Response Structure:**
```typescript
interface CampaignPerformanceResponse {
  data: {
    campaigns: Array<{
      campaignId: string;
      campaignName: string;
      status: 'active' | 'paused' | 'completed';
      startDate: string;
      endDate?: string;
      goalAmount?: number;
      currentPeriod: {
        totalRaised: number;
        donationCount: number;
        averageDonation: number;
        totalDonors: number;
        newDonors: number;
        retentionRate: number;
        goalProgress?: number;
        roi?: number;
      };
      comparisonPeriod?: {
        totalRaised: number;
        donationCount: number;
        averageDonation: number;
        totalDonors: number;
        newDonors: number;
        retentionRate: number;
      };
      timeSeriesData: Array<{
        date: string;
        totalRaised: number;
        donationCount: number;
        newDonors: number;
      }>;
      performanceRanking: number; // 1-based ranking among selected campaigns
    }>;
    summary: {
      totalCampaigns: number;
      bestPerformingCampaign: {
        campaignId: string;
        campaignName: string;
        metric: 'revenue' | 'donors' | 'roi';
        value: number;
      };
      campaignComparison: {
        averageROI: number;
        averageRetentionRate: number;
        totalCombinedRevenue: number;
      };
    };
  };
  meta: {
    selectedCampaigns: string[];
    granularity: 'daily' | 'weekly' | 'monthly';
    cached: boolean;
    lastUpdated: string;
  };
}
```

### Recharts Implementation Context
**Multi-Line Campaign Chart Configuration:**
```typescript
// Campaign performance multi-line chart
<ResponsiveContainer width="100%" height={500}>
  <LineChart data={campaignData} margin={{ top: 20, right: 30, left: 20, bottom: 20 }}>
    <CartesianGrid strokeDasharray="3 3" />
    <XAxis
      dataKey="date"
      tickFormatter={(date) => format(new Date(date), 'MMM dd')}
    />
    <YAxis
      yAxisId="revenue"
      orientation="left"
      tickFormatter={(value) => `$${(value / 1000).toFixed(0)}k`}
    />
    <YAxis
      yAxisId="donors"
      orientation="right"
      tickFormatter={(value) => value.toLocaleString()}
    />
    <Tooltip content={<CampaignTooltip />} />
    <Legend />

    {selectedCampaigns.map((campaign, index) => (
      <React.Fragment key={campaign.campaignId}>
        {/* Revenue line */}
        <Line
          yAxisId="revenue"
          type="monotone"
          dataKey={`${campaign.campaignId}_revenue`}
          stroke={campaignColors[index % campaignColors.length]}
          strokeWidth={2}
          name={`${campaign.campaignName} - Revenue`}
          dot={{ r: 4 }}
        />

        {/* Optional: Donor count line with different styling */}
        {showDonorLines && (
          <Line
            yAxisId="donors"
            type="monotone"
            dataKey={`${campaign.campaignId}_donors`}
            stroke={campaignColors[index % campaignColors.length]}
            strokeWidth={1}
            strokeDasharray="3 3"
            name={`${campaign.campaignName} - Donors`}
            dot={{ r: 2 }}
          />
        )}
      </React.Fragment>
    ))}
  </LineChart>
</ResponsiveContainer>
```

**Custom Campaign Tooltip:**
```typescript
const CampaignTooltip = ({ active, payload, label }: any) => {
  if (active && payload && payload.length) {
    const date = format(new Date(label), 'MMMM dd, yyyy');

    return (
      <div className="bg-white p-4 border border-gray-200 rounded-lg shadow-lg max-w-sm">
        <p className="font-semibold text-gray-800 mb-2">{date}</p>
        <div className="space-y-2">
          {payload.map((entry: any, index: number) => {
            const [campaignId, metric] = entry.dataKey.split('_');
            const campaignName = getCampaignName(campaignId);

            return (
              <div key={index} className="flex items-center justify-between">
                <div className="flex items-center">
                  <div
                    className="w-3 h-3 rounded-full mr-2"
                    style={{ backgroundColor: entry.color }}
                  />
                  <span className="text-sm font-medium truncate">
                    {campaignName}
                  </span>
                </div>
                <span className="text-sm font-semibold ml-2">
                  {metric === 'revenue'
                    ? `$${entry.value.toLocaleString()}`
                    : `${entry.value} donors`
                  }
                </span>
              </div>
            );
          })}
        </div>

        {/* Campaign comparison indicators */}
        <div className="mt-3 pt-2 border-t border-gray-100">
          <div className="text-xs text-gray-500">
            Best performer: {getBestPerformer(payload)}
          </div>
        </div>
      </div>
    );
  }
  return null;
};
```

### Campaign Selection Implementation
**Multi-Select Campaign Interface:**
```typescript
interface CampaignSelectorProps {
  availableCampaigns: Campaign[];
  selectedCampaigns: Campaign[];
  onSelectionChange: (campaigns: Campaign[]) => void;
  maxSelections?: number;
}

const CampaignSelector: React.FC<CampaignSelectorProps> = ({
  availableCampaigns,
  selectedCampaigns,
  onSelectionChange,
  maxSelections = 6
}) => {
  const [searchTerm, setSearchTerm] = useState('');
  const [isOpen, setIsOpen] = useState(false);

  const filteredCampaigns = availableCampaigns.filter(campaign =>
    campaign.name.toLowerCase().includes(searchTerm.toLowerCase()) ||
    campaign.status.toLowerCase().includes(searchTerm.toLowerCase())
  );

  const handleCampaignToggle = (campaign: Campaign) => {
    const isSelected = selectedCampaigns.find(c => c.id === campaign.id);

    if (isSelected) {
      // Remove campaign
      onSelectionChange(selectedCampaigns.filter(c => c.id !== campaign.id));
    } else {
      // Add campaign (if not at max limit)
      if (selectedCampaigns.length < maxSelections) {
        onSelectionChange([...selectedCampaigns, campaign]);
      }
    }
  };

  return (
    <div className="relative">
      {/* Selected Campaigns Display */}
      {selectedCampaigns.length > 0 && (
        <div className="mb-3 flex flex-wrap gap-2">
          {selectedCampaigns.map(campaign => (
            <div
              key={campaign.id}
              className="inline-flex items-center px-3 py-1 rounded-full text-sm bg-blue-100 text-blue-800"
            >
              <span className="truncate max-w-32">{campaign.name}</span>
              <button
                onClick={() => handleCampaignToggle(campaign)}
                className="ml-2 text-blue-600 hover:text-blue-800"
              >
                ×
              </button>
            </div>
          ))}
        </div>
      )}

      {/* Campaign Selection Dropdown */}
      <div className="relative">
        <button
          onClick={() => setIsOpen(!isOpen)}
          className="w-full px-3 py-2 text-left border border-gray-300 rounded-md bg-white hover:bg-gray-50"
        >
          <span className="text-gray-700">
            {selectedCampaigns.length === 0
              ? 'Select campaigns to compare'
              : `${selectedCampaigns.length} campaign${selectedCampaigns.length !== 1 ? 's' : ''} selected`
            }
          </span>
          <span className="float-right text-gray-400">▼</span>
        </button>

        {isOpen && (
          <div className="absolute z-10 w-full mt-1 bg-white border border-gray-300 rounded-md shadow-lg max-h-60 overflow-auto">
            {/* Search Input */}
            <div className="p-2 border-b border-gray-200">
              <input
                type="text"
                value={searchTerm}
                onChange={(e) => setSearchTerm(e.target.value)}
                placeholder="Search campaigns..."
                className="w-full px-2 py-1 text-sm border border-gray-300 rounded"
              />
            </div>

            {/* Quick Actions */}
            <div className="p-2 border-b border-gray-200 text-xs">
              <button
                onClick={() => {
                  const activeCampaigns = availableCampaigns
                    .filter(c => c.status === 'active')
                    .slice(0, maxSelections);
                  onSelectionChange(activeCampaigns);
                }}
                className="text-blue-600 hover:text-blue-800 mr-4"
              >
                Select All Active
              </button>
              <button
                onClick={() => onSelectionChange([])}
                className="text-red-600 hover:text-red-800"
              >
                Clear All
              </button>
            </div>

            {/* Campaign Options */}
            <div className="max-h-40 overflow-y-auto">
              {filteredCampaigns.map(campaign => (
                <div
                  key={campaign.id}
                  onClick={() => handleCampaignToggle(campaign)}
                  className={`px-3 py-2 cursor-pointer hover:bg-gray-100 ${
                    selectedCampaigns.find(c => c.id === campaign.id) ? 'bg-blue-50' : ''
                  }`}
                >
                  <div className="flex items-center justify-between">
                    <span className="text-sm font-medium truncate">
                      {campaign.name}
                    </span>
                    <span className={`text-xs px-2 py-1 rounded ${
                      campaign.status === 'active' ? 'bg-green-100 text-green-800' :
                      campaign.status === 'paused' ? 'bg-yellow-100 text-yellow-800' :
                      'bg-gray-100 text-gray-800'
                    }`}>
                      {campaign.status}
                    </span>
                  </div>
                  {campaign.goalAmount && (
                    <div className="text-xs text-gray-500 mt-1">
                      Goal: ${campaign.goalAmount.toLocaleString()}
                    </div>
                  )}
                </div>
              ))}
            </div>

            {selectedCampaigns.length >= maxSelections && (
              <div className="p-2 text-xs text-amber-600 bg-amber-50 border-t border-amber-200">
                Maximum {maxSelections} campaigns selected for optimal chart readability
              </div>
            )}
          </div>
        )}
      </div>
    </div>
  );
};
```

### Performance Metrics Implementation
**Campaign Performance Calculations:**
```typescript
interface CampaignMetrics {
  campaignId: string;
  totalRaised: number;
  donationCount: number;
  averageDonation: number;
  totalDonors: number;
  newDonors: number;
  retentionRate: number;
  goalProgress?: number;
  roi?: number;
  acquisitionCost?: number;
}

export class CampaignPerformanceCalculations {
  /**
   * Calculate campaign ROI when cost data is available
   */
  static calculateROI(
    totalRaised: number,
    campaignCost: number
  ): { roi: number; returnMultiple: number } {
    if (campaignCost <= 0) {
      return { roi: 0, returnMultiple: 0 };
    }

    const roi = ((totalRaised - campaignCost) / campaignCost) * 100;
    const returnMultiple = totalRaised / campaignCost;

    return { roi, returnMultiple };
  }

  /**
   * Calculate goal progress percentage
   */
  static calculateGoalProgress(
    totalRaised: number,
    goalAmount: number
  ): number {
    if (goalAmount <= 0) return 0;
    return Math.min((totalRaised / goalAmount) * 100, 100);
  }

  /**
   * Calculate campaign efficiency metrics
   */
  static calculateEfficiencyMetrics(
    campaigns: CampaignMetrics[]
  ): {
    bestPerformer: { metric: string; campaignId: string; value: number };
    averageMetrics: { roi: number; retentionRate: number; avgDonation: number };
    rankings: Map<string, { revenue: number; donors: number; efficiency: number }>;
  } {
    // Find best performers by different metrics
    const bestRevenue = campaigns.reduce((best, current) =>
      current.totalRaised > best.totalRaised ? current : best
    );

    const bestROI = campaigns
      .filter(c => c.roi !== undefined && c.roi > 0)
      .reduce((best, current) =>
        (current.roi || 0) > (best.roi || 0) ? current : best, campaigns[0]
      );

    // Calculate averages
    const validROIs = campaigns.filter(c => c.roi !== undefined);
    const averageROI = validROIs.length > 0
      ? validROIs.reduce((sum, c) => sum + (c.roi || 0), 0) / validROIs.length
      : 0;

    const averageRetention = campaigns.reduce((sum, c) => sum + c.retentionRate, 0) / campaigns.length;
    const averageGift = campaigns.reduce((sum, c) => sum + c.averageDonation, 0) / campaigns.length;

    // Create rankings
    const rankings = new Map<string, { revenue: number; donors: number; efficiency: number }>();

    const sortedByRevenue = [...campaigns].sort((a, b) => b.totalRaised - a.totalRaised);
    const sortedByDonors = [...campaigns].sort((a, b) => b.totalDonors - a.totalDonors);
    const sortedByROI = [...campaigns].sort((a, b) => (b.roi || 0) - (a.roi || 0));

    campaigns.forEach(campaign => {
      rankings.set(campaign.campaignId, {
        revenue: sortedByRevenue.findIndex(c => c.campaignId === campaign.campaignId) + 1,
        donors: sortedByDonors.findIndex(c => c.campaignId === campaign.campaignId) + 1,
        efficiency: sortedByROI.findIndex(c => c.campaignId === campaign.campaignId) + 1
      });
    });

    return {
      bestPerformer: {
        metric: 'revenue',
        campaignId: bestRevenue.campaignId,
        value: bestRevenue.totalRaised
      },
      averageMetrics: {
        roi: averageROI,
        retentionRate: averageRetention,
        avgDonation: averageGift
      },
      rankings
    };
  }
}
```

### File Locations and Naming Conventions
**Chart Component Files:**
- `apps/web/components/charts/CampaignPerformanceChart.tsx` - Main campaign chart
- `apps/web/components/charts/CampaignTooltip.tsx` - Custom tooltip component
- `apps/web/components/filters/CampaignSelector.tsx` - Campaign selection interface
- `apps/web/components/tables/CampaignPerformanceTable.tsx` - Campaign data table

**API Route Files:**
- `apps/web/app/api/v1/analytics/campaign-performance/route.ts` - Campaign analytics endpoint

**Calculation and Utility Files:**
- `apps/web/lib/calculations/campaignPerformanceCalculations.ts` - Campaign analysis utilities
- `apps/web/hooks/useCampaignPerformanceData.ts` - Data fetching hook
- `packages/shared/types/campaignPerformance.ts` - TypeScript interfaces

### Query Collaboration Context
**Campaign Performance Query Request Template:**
```typescript
const campaignPerformanceQueryRequest: QueryCollaborationRequest = {
  chartType: 'campaign-performance',
  requiredFields: [
    'pw_appeal.id',
    'pw_appeal.appeal_name',
    'pw_appeal.status',
    'pw_appeal.start_date',
    'pw_appeal.end_date',
    'pw_appeal.goal_amount',
    'pw_transactions.donation_date',
    'pw_transactions.amount',
    'pw_transactions.member_id',
    'pw_transactions.status',
    'pw_transactions.freq'
  ],
  timeFiltering: {
    dateRangeSupport: true,
    granularity: 'daily',
    comparisonPeriods: true
  },
  aggregationNeeds: [
    'COUNT(DISTINCT pw_transactions.id) as donation_count',
    'SUM(pw_transactions.amount) as total_raised',
    'AVG(pw_transactions.amount) as average_donation',
    'COUNT(DISTINCT pw_transactions.member_id) as total_donors',
    'campaign retention calculations',
    'goal progress calculations'
  ],
  expectedPerformance: {
    maxExecutionTime: '1000ms',
    expectedRowCount: 'variable based on selected campaigns and date range',
    indexingRequirements: [
      'INDEX on (pw_transactions.appeal_id, donation_date, status)',
      'INDEX on (pw_appeal.status, start_date)',
      'INDEX on (pw_transactions.member_id, donation_date) for retention calculations'
    ]
  },
  sampleDataFormat: {
    campaignId: 'camp_001',
    campaignName: 'Annual Giving 2024',
    date: '2024-09-26',
    totalRaised: 12450.50,
    donationCount: 89,
    totalDonors: 76,
    newDonors: 12,
    retentionRate: 65.8
  }
};
```

## Testing

### Testing Standards [Source: docs/architecture.md#technology-stack-table]
**Testing Framework:** Jest + React Testing Library for component testing
**Test File Location:** `__tests__/` directories alongside campaign components
**Testing Patterns:**
- Component rendering tests for campaign chart and selection interface
- Multi-campaign data visualization tests with color coding verification
- Campaign performance calculation tests with ROI and goal progress scenarios
- Filter integration tests ensuring proper campaign analysis

**Specific Testing Requirements for This Story:**
- Campaign performance multi-line chart rendering with proper color coding
- Campaign selection interface with search, multi-select, and limit functionality
- Performance metrics calculation accuracy including ROI and retention rates
- Comparison period overlay functionality for campaign performance changes
- Data table rendering with campaign ranking and sortable metrics
- Filter integration for campaign-specific analysis by date ranges and segments
- Query collaboration system testing with mock user-provided queries

**Test Files to Create:**
- `apps/web/components/charts/__tests__/CampaignPerformanceChart.test.tsx` - Chart component tests
- `apps/web/components/filters/__tests__/CampaignSelector.test.tsx` - Selection interface tests
- `apps/web/components/tables/__tests__/CampaignPerformanceTable.test.tsx` - Table component tests
- `apps/web/lib/calculations/__tests__/campaignPerformanceCalculations.test.ts` - Calculation tests
- `apps/web/hooks/__tests__/useCampaignPerformanceData.test.ts` - Data fetching hook tests
- `apps/web/__tests__/api/campaign-performance.test.ts` - API endpoint tests

## Change Log

| Date | Version | Description | Author |
|------|---------|-------------|---------|
| 2025-09-26 | 1.0 | Initial story creation with comprehensive campaign performance analytics implementation | Claude (Story Agent) |

## Dev Agent Record

*This section will be populated by the development agent during implementation*

### Agent Model Used
*To be filled by dev agent*

### Debug Log References
*To be filled by dev agent*

### Completion Notes List
*To be filled by dev agent*

### File List
*To be filled by dev agent*

## QA Results

*Results from QA Agent review will be populated here*