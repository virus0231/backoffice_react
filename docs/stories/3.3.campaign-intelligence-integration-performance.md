# Story 3.3: Campaign Intelligence Integration & Performance

## Status
Draft

## Story

**As a** fundraising manager,
**I want** campaign and traffic source analytics loading efficiently with cross-chart insights,
**so that** I can understand campaign effectiveness and channel performance for strategic decisions.

## Acceptance Criteria

1. Optimized data fetching for campaign and traffic source charts reducing redundant database queries
2. Cross-chart insights showing relationships between campaigns and traffic sources
3. User query collaboration system for campaign and attribution logic with agent optimization
4. Performance optimization ensuring fast loading for campaign intelligence analysis
5. Shared comparison period synchronization across campaign intelligence visualizations
6. Basic export functionality for campaign performance reports (CSV format)
7. Loading states and error handling for campaign attribution data processing

## Tasks / Subtasks

- [ ] Implement optimized data fetching for campaign intelligence (AC: 1)
  - [ ] Create unified data fetching hook `useCampaignIntelligenceData` combining campaign and traffic source queries
  - [ ] Implement parallel API calls for campaign performance and traffic source analytics
  - [ ] Add intelligent caching preventing redundant database queries for related data
  - [ ] Create data prefetching for campaign intelligence section when user navigates to dashboard
  - [ ] Optimize query bundling for campaigns and their associated traffic sources
  - [ ] Add database connection pooling optimization for concurrent campaign intelligence queries
- [ ] Build cross-chart insights and relationships (AC: 2)
  - [ ] Create CampaignIntelligenceSummary component in `apps/web/components/analytics/CampaignIntelligenceSummary.tsx`
  - [ ] Implement cross-analysis showing which traffic sources perform best for specific campaigns
  - [ ] Add campaign-source correlation analysis identifying optimal channel-campaign combinations
  - [ ] Create insights widget showing top-performing campaign-source pairs
  - [ ] Build attribution flow visualization showing donor journey from source to campaign conversion
  - [ ] Add recommendations engine suggesting campaign optimization based on traffic source performance
- [ ] Establish comprehensive query collaboration system (AC: 3)
  - [ ] Create campaign intelligence query request templates combining both chart types
  - [ ] Document campaign-source attribution logic and relationship mapping requirements
  - [ ] Establish user collaboration workflow for complex cross-chart query optimization
  - [ ] Create validation system ensuring data consistency between campaign and source analytics
  - [ ] Implement agent optimization for cross-chart query performance and accuracy
  - [ ] Add query collaboration documentation and best practices guide
- [ ] Implement campaign intelligence performance optimization (AC: 4)
  - [ ] Create performance monitoring specifically for campaign intelligence section
  - [ ] Implement progressive loading: load campaign performance first, then traffic source overlay
  - [ ] Add intelligent pre-loading of likely-to-be-viewed campaign combinations
  - [ ] Optimize bundle splitting for campaign intelligence components reducing initial load
  - [ ] Create performance budgets ensuring sub-3-second load times for campaign intelligence
  - [ ] Add performance alerts for campaign intelligence query degradation
- [ ] Synchronize comparison periods across campaign intelligence (AC: 5)
  - [ ] Extend comparison store to handle campaign intelligence coordination
  - [ ] Create shared comparison state between campaign performance and traffic source charts
  - [ ] Implement synchronized comparison period selection affecting both visualizations
  - [ ] Add comparison period validation ensuring consistency across campaign intelligence charts
  - [ ] Create comparison summary showing campaign intelligence changes between periods
  - [ ] Build comparison insights highlighting significant changes in campaign-source relationships
- [ ] Build campaign intelligence export functionality (AC: 6)
  - [ ] Create CampaignIntelligenceExport component for comprehensive reporting
  - [ ] Implement CSV export combining campaign performance and traffic source data
  - [ ] Add campaign-source relationship export with correlation metrics
  - [ ] Create formatted reports suitable for campaign intelligence strategic analysis
  - [ ] Include comparison period data in campaign intelligence exports
  - [ ] Add export options respecting current filter selections and chart combinations
- [ ] Implement comprehensive error handling and loading states (AC: 7)
  - [ ] Create CampaignIntelligenceErrorBoundary for section-wide error handling
  - [ ] Implement coordinated loading states across campaign performance and traffic source charts
  - [ ] Add campaign attribution data processing error handling with user-friendly messages
  - [ ] Create fallback states when campaign intelligence data is partially unavailable
  - [ ] Implement retry mechanisms for failed campaign intelligence queries
  - [ ] Add loading progress indicators for complex campaign attribution processing

## Dev Notes

### Previous Story Insights
**Story Dependencies:** This story serves as the integration and optimization capstone for Epic 3: Campaign Intelligence, building on campaign performance analytics (Story 3.1) and traffic source analytics (Story 3.2), while leveraging all foundation systems (Stories 1.1-2.4).

### Technical Architecture Context
**Campaign Intelligence Requirements:** [Source: docs/prd.md#epic-3-campaign-intelligence]
- Essential campaign effectiveness insights and fundamental attribution data
- Campaign performance tracking and basic traffic source analytics
- Cross-chart insights showing relationships between campaigns and traffic sources
- Performance optimization for strategic decision making

**Integration Patterns:** [Source: docs/architecture.md#architectural-patterns]
- Progressive Enhancement: Server-rendered baseline with client-side interactivity
- Server Component Data Fetching: Initial chart data loaded server-side
- Client-Side State Management: Zustand for filter state and real-time updates
- API Routes Pattern: Next.js `/api` directory for all backend functionality

### Cross-Chart Analytics Implementation
**Campaign-Source Correlation Analysis:**
```typescript
interface CampaignSourceCorrelation {
  campaignId: string;
  campaignName: string;
  sourceName: string;
  totalRaised: number;
  donationCount: number;
  conversionRate: number;
  correlationStrength: 'high' | 'moderate' | 'low';
  performanceIndex: number; // Normalized 0-100 score
}

interface CampaignIntelligenceInsights {
  topPerformingPairs: CampaignSourceCorrelation[];
  sourceEffectivenessByCampaign: Map<string, SourcePerformance[]>;
  campaignEffectivenessBySource: Map<string, CampaignPerformance[]>;
  recommendations: StrategicRecommendation[];
  attributionFlow: AttributionFlowData;
}

export class CampaignIntelligenceAnalyzer {
  /**
   * Analyze relationships between campaigns and traffic sources
   */
  static analyzeCampaignSourceRelationships(
    campaignData: CampaignPerformanceData[],
    trafficSourceData: TrafficSourceData[]
  ): CampaignIntelligenceInsights {
    const correlations = this.calculateCorrelations(campaignData, trafficSourceData);
    const topPairs = this.identifyTopPerformingPairs(correlations);

    return {
      topPerformingPairs: topPairs,
      sourceEffectivenessByCampaign: this.groupSourcesByCampaign(correlations),
      campaignEffectivenessBySource: this.groupCampaignsBySource(correlations),
      recommendations: this.generateStrategicRecommendations(correlations),
      attributionFlow: this.buildAttributionFlow(campaignData, trafficSourceData)
    };
  }

  /**
   * Calculate correlation strength between campaigns and sources
   */
  private static calculateCorrelations(
    campaignData: CampaignPerformanceData[],
    trafficSourceData: TrafficSourceData[]
  ): CampaignSourceCorrelation[] {
    const correlations: CampaignSourceCorrelation[] = [];

    campaignData.forEach(campaign => {
      trafficSourceData.forEach(source => {
        // Calculate performance metrics for this campaign-source pair
        const performance = this.calculatePairPerformance(campaign, source);

        if (performance.donationCount > 0) {
          correlations.push({
            campaignId: campaign.campaignId,
            campaignName: campaign.campaignName,
            sourceName: source.sourceName,
            totalRaised: performance.totalRaised,
            donationCount: performance.donationCount,
            conversionRate: performance.conversionRate,
            correlationStrength: this.determineCorrelationStrength(performance),
            performanceIndex: this.calculatePerformanceIndex(performance)
          });
        }
      });
    });

    return correlations.sort((a, b) => b.performanceIndex - a.performanceIndex);
  }

  /**
   * Generate strategic recommendations based on campaign-source analysis
   */
  private static generateStrategicRecommendations(
    correlations: CampaignSourceCorrelation[]
  ): StrategicRecommendation[] {
    const recommendations: StrategicRecommendation[] = [];

    // Identify underperforming campaign-source combinations
    const underperforming = correlations.filter(c =>
      c.correlationStrength === 'low' && c.donationCount > 5
    );

    underperforming.forEach(pair => {
      recommendations.push({
        type: 'optimization',
        priority: 'medium',
        title: `Optimize ${pair.campaignName} performance via ${pair.sourceName}`,
        description: `This campaign-source combination has low conversion rates. Consider adjusting messaging or targeting.`,
        expectedImpact: 'moderate',
        actionItems: [
          `Review ${pair.sourceName} targeting for ${pair.campaignName}`,
          'A/B test different messaging approaches',
          'Analyze successful campaigns from this source for best practices'
        ]
      });
    });

    // Identify high-performing combinations to scale
    const topPerformers = correlations.slice(0, 3);
    topPerformers.forEach(pair => {
      recommendations.push({
        type: 'scaling',
        priority: 'high',
        title: `Scale successful ${pair.campaignName} + ${pair.sourceName} combination`,
        description: `This combination shows strong performance with $${pair.totalRaised.toLocaleString()} raised. Consider increasing investment.`,
        expectedImpact: 'high',
        actionItems: [
          `Increase budget allocation for ${pair.sourceName} campaigns`,
          'Replicate successful elements in other campaigns',
          'Test similar approaches with comparable campaigns'
        ]
      });
    });

    return recommendations;
  }

  /**
   * Build attribution flow showing donor journey from source to conversion
   */
  private static buildAttributionFlow(
    campaignData: CampaignPerformanceData[],
    trafficSourceData: TrafficSourceData[]
  ): AttributionFlowData {
    const flowNodes: FlowNode[] = [];
    const flowEdges: FlowEdge[] = [];

    // Create source nodes
    trafficSourceData.forEach(source => {
      flowNodes.push({
        id: `source-${source.sourceName}`,
        type: 'source',
        label: source.displayName,
        value: source.currentPeriod.donationCount,
        color: trafficSourceColors[source.sourceName]
      });
    });

    // Create campaign nodes
    campaignData.forEach(campaign => {
      flowNodes.push({
        id: `campaign-${campaign.campaignId}`,
        type: 'campaign',
        label: campaign.campaignName,
        value: campaign.currentPeriod.donationCount,
        color: campaignColors[campaign.campaignId] || '#6b7280'
      });
    });

    // Create edges showing attribution flow
    // This would require additional data about source-to-campaign attribution
    // For now, create simplified representation based on available data

    return {
      nodes: flowNodes,
      edges: flowEdges,
      totalFlow: campaignData.reduce((sum, c) => sum + c.currentPeriod.donationCount, 0)
    };
  }
}

interface StrategicRecommendation {
  type: 'optimization' | 'scaling' | 'investigation';
  priority: 'high' | 'medium' | 'low';
  title: string;
  description: string;
  expectedImpact: 'high' | 'moderate' | 'low';
  actionItems: string[];
}
```

### Unified Data Fetching Implementation
**Campaign Intelligence Data Hook:**
```typescript
interface CampaignIntelligenceData {
  campaigns: CampaignPerformanceData[];
  trafficSources: TrafficSourceData[];
  crossAnalysis: CampaignIntelligenceInsights;
  summary: CampaignIntelligenceSummary;
}

export const useCampaignIntelligenceData = (filters: FilterState) => {
  const [data, setData] = useState<CampaignIntelligenceData | null>(null);
  const [isLoading, setIsLoading] = useState(false);
  const [error, setError] = useState<Error | null>(null);

  const fetchCampaignIntelligence = useCallback(async () => {
    setIsLoading(true);
    setError(null);

    try {
      const params = new URLSearchParams({
        startDate: filters.dateRange.startDate.toISOString(),
        endDate: filters.dateRange.endDate.toISOString(),
        ...(filters.selectedAppeal && { appealId: filters.selectedAppeal.id }),
        ...(filters.selectedFund && { fundId: filters.selectedFund.id }),
        ...(filters.frequency !== 'all' && { frequency: filters.frequency })
      });

      // Parallel API calls for optimal performance
      const [campaignResponse, trafficSourceResponse] = await Promise.all([
        fetch(`/api/v1/analytics/campaign-performance?${params}`),
        fetch(`/api/v1/analytics/traffic-sources?${params}`)
      ]);

      if (!campaignResponse.ok || !trafficSourceResponse.ok) {
        throw new Error('Failed to fetch campaign intelligence data');
      }

      const [campaignData, trafficSourceData] = await Promise.all([
        campaignResponse.json(),
        trafficSourceResponse.json()
      ]);

      // Perform cross-analysis
      const crossAnalysis = CampaignIntelligenceAnalyzer.analyzeCampaignSourceRelationships(
        campaignData.data.campaigns,
        trafficSourceData.data.sources
      );

      // Build summary
      const summary = {
        totalCampaigns: campaignData.data.campaigns.length,
        totalSources: trafficSourceData.data.sources.length,
        topPerformingPair: crossAnalysis.topPerformingPairs[0],
        totalRevenueTracked: campaignData.data.campaigns.reduce(
          (sum: number, c: any) => sum + c.currentPeriod.totalRaised, 0
        ),
        recommendationCount: crossAnalysis.recommendations.length
      };

      setData({
        campaigns: campaignData.data.campaigns,
        trafficSources: trafficSourceData.data.sources,
        crossAnalysis,
        summary
      });

    } catch (err) {
      setError(err instanceof Error ? err : new Error('Unknown error occurred'));
    } finally {
      setIsLoading(false);
    }
  }, [filters]);

  useEffect(() => {
    fetchCampaignIntelligence();
  }, [fetchCampaignIntelligence]);

  return {
    data,
    isLoading,
    error,
    refetch: fetchCampaignIntelligence
  };
};
```

### Campaign Intelligence Summary Component
**Cross-Chart Insights Display:**
```typescript
interface CampaignIntelligenceSummaryProps {
  insights: CampaignIntelligenceInsights;
  summary: CampaignIntelligenceSummary;
  isLoading?: boolean;
}

const CampaignIntelligenceSummary: React.FC<CampaignIntelligenceSummaryProps> = ({
  insights,
  summary,
  isLoading = false
}) => {
  if (isLoading) {
    return <CampaignIntelligenceSkeleton />;
  }

  return (
    <div className="bg-white rounded-lg shadow-sm border p-6 mb-6">
      <div className="flex items-center justify-between mb-4">
        <h2 className="text-lg font-semibold text-gray-900">
          Campaign Intelligence Summary
        </h2>
        <div className="text-sm text-gray-500">
          Analyzing {summary.totalCampaigns} campaigns across {summary.totalSources} sources
        </div>
      </div>

      {/* Key Metrics Grid */}
      <div className="grid grid-cols-1 md:grid-cols-3 gap-4 mb-6">
        <div className="bg-blue-50 rounded-lg p-4">
          <div className="text-2xl font-bold text-blue-600">
            ${summary.totalRevenueTracked.toLocaleString()}
          </div>
          <div className="text-sm text-blue-700">Total Revenue Tracked</div>
        </div>

        <div className="bg-green-50 rounded-lg p-4">
          <div className="text-2xl font-bold text-green-600">
            {insights.topPerformingPairs.length}
          </div>
          <div className="text-sm text-green-700">High-Performing Combinations</div>
        </div>

        <div className="bg-purple-50 rounded-lg p-4">
          <div className="text-2xl font-bold text-purple-600">
            {summary.recommendationCount}
          </div>
          <div className="text-sm text-purple-700">Strategic Recommendations</div>
        </div>
      </div>

      {/* Top Performing Campaign-Source Pairs */}
      <div className="mb-6">
        <h3 className="text-md font-medium text-gray-800 mb-3">
          Top Campaign-Source Combinations
        </h3>
        <div className="space-y-2">
          {insights.topPerformingPairs.slice(0, 3).map((pair, index) => (
            <div
              key={`${pair.campaignId}-${pair.sourceName}`}
              className="flex items-center justify-between p-3 bg-gray-50 rounded-lg"
            >
              <div className="flex items-center">
                <div className="w-6 h-6 rounded-full bg-blue-100 text-blue-600 text-xs font-semibold flex items-center justify-center mr-3">
                  {index + 1}
                </div>
                <div>
                  <div className="font-medium text-gray-900">
                    {pair.campaignName}
                  </div>
                  <div className="text-sm text-gray-600">
                    via {getDisplayName(pair.sourceName)}
                  </div>
                </div>
              </div>
              <div className="text-right">
                <div className="font-semibold text-gray-900">
                  ${pair.totalRaised.toLocaleString()}
                </div>
                <div className="text-sm text-gray-600">
                  {pair.donationCount} donations
                </div>
              </div>
            </div>
          ))}
        </div>
      </div>

      {/* Strategic Recommendations */}
      {insights.recommendations.length > 0 && (
        <div>
          <h3 className="text-md font-medium text-gray-800 mb-3">
            Strategic Recommendations
          </h3>
          <div className="space-y-3">
            {insights.recommendations.slice(0, 2).map((rec, index) => (
              <div key={index} className="border-l-4 border-blue-400 pl-4">
                <div className="flex items-center justify-between mb-1">
                  <div className="font-medium text-gray-900">{rec.title}</div>
                  <span className={`px-2 py-1 rounded text-xs font-medium ${
                    rec.priority === 'high' ? 'bg-red-100 text-red-800' :
                    rec.priority === 'medium' ? 'bg-yellow-100 text-yellow-800' :
                    'bg-gray-100 text-gray-800'
                  }`}>
                    {rec.priority} priority
                  </span>
                </div>
                <div className="text-sm text-gray-600 mb-2">
                  {rec.description}
                </div>
                <div className="text-xs text-gray-500">
                  Expected impact: {rec.expectedImpact}
                </div>
              </div>
            ))}
          </div>
        </div>
      )}
    </div>
  );
};
```

### Performance Optimization Implementation
**Campaign Intelligence Performance Monitor:**
```typescript
class CampaignIntelligencePerformanceMonitor {
  private loadingMetrics = new Map<string, number>();

  trackSectionLoad(sectionId: string): PerformanceTracker {
    const startTime = performance.now();
    this.loadingMetrics.set(`${sectionId}-start`, startTime);

    return {
      markDataLoaded: () => {
        const dataLoadTime = performance.now() - startTime;
        this.loadingMetrics.set(`${sectionId}-data`, dataLoadTime);

        return {
          markRenderComplete: () => {
            const totalTime = performance.now() - startTime;
            this.loadingMetrics.set(`${sectionId}-total`, totalTime);

            this.analyzeSectionPerformance(sectionId, {
              dataLoadTime,
              totalTime,
              renderTime: totalTime - dataLoadTime
            });
          }
        };
      }
    };
  }

  private analyzeSectionPerformance(
    sectionId: string,
    metrics: SectionPerformanceMetrics
  ): void {
    const PERFORMANCE_THRESHOLDS = {
      dataLoad: 2000,    // 2 seconds
      totalLoad: 3000,   // 3 seconds
      render: 500        // 0.5 seconds
    };

    const issues: PerformanceIssue[] = [];

    if (metrics.dataLoadTime > PERFORMANCE_THRESHOLDS.dataLoad) {
      issues.push({
        type: 'slow-data-fetch',
        severity: 'high',
        message: `${sectionId} data loading took ${metrics.dataLoadTime}ms (threshold: ${PERFORMANCE_THRESHOLDS.dataLoad}ms)`,
        recommendations: [
          'Consider implementing data caching',
          'Optimize database queries',
          'Add data prefetching'
        ]
      });
    }

    if (metrics.renderTime > PERFORMANCE_THRESHOLDS.render) {
      issues.push({
        type: 'slow-rendering',
        severity: 'medium',
        message: `${sectionId} rendering took ${metrics.renderTime}ms`,
        recommendations: [
          'Optimize component rendering',
          'Consider virtualization for large datasets',
          'Implement memoization for expensive calculations'
        ]
      });
    }

    if (metrics.totalTime > PERFORMANCE_THRESHOLDS.totalLoad) {
      issues.push({
        type: 'total-load-time',
        severity: 'high',
        message: `${sectionId} total load time exceeded budget: ${metrics.totalTime}ms`,
        recommendations: [
          'Implement progressive loading',
          'Add loading skeletons',
          'Consider breaking into smaller components'
        ]
      });
    }

    if (issues.length > 0) {
      this.reportPerformanceIssues(sectionId, issues);
    }
  }

  private reportPerformanceIssues(
    sectionId: string,
    issues: PerformanceIssue[]
  ): void {
    console.warn(`Performance issues detected in ${sectionId}:`, issues);

    // In production, send to monitoring service
    if (process.env.NODE_ENV === 'production') {
      // Analytics service integration
      issues.forEach(issue => {
        gtag('event', 'performance_issue', {
          section: sectionId,
          issue_type: issue.type,
          severity: issue.severity,
          load_time: this.loadingMetrics.get(`${sectionId}-total`)
        });
      });
    }
  }
}

const performanceMonitor = new CampaignIntelligencePerformanceMonitor();

// Usage in campaign intelligence components
export const useCampaignIntelligencePerformance = (sectionId: string) => {
  const trackerRef = useRef<PerformanceTracker | null>(null);

  const startTracking = useCallback(() => {
    trackerRef.current = performanceMonitor.trackSectionLoad(sectionId);
  }, [sectionId]);

  const markDataLoaded = useCallback(() => {
    if (trackerRef.current) {
      const renderTracker = trackerRef.current.markDataLoaded();
      trackerRef.current = null;
      return renderTracker;
    }
    return null;
  }, []);

  return { startTracking, markDataLoaded };
};
```

### Export Functionality Implementation
**Campaign Intelligence Export System:**
```typescript
interface CampaignIntelligenceExportData {
  campaigns: CampaignPerformanceData[];
  trafficSources: TrafficSourceData[];
  correlations: CampaignSourceCorrelation[];
  recommendations: StrategicRecommendation[];
  summary: CampaignIntelligenceSummary;
}

export class CampaignIntelligenceExporter {
  /**
   * Export comprehensive campaign intelligence report as CSV
   */
  static exportToCsv(data: CampaignIntelligenceExportData): void {
    const csvSections: string[] = [];

    // Executive Summary
    csvSections.push('CAMPAIGN INTELLIGENCE EXECUTIVE SUMMARY');
    csvSections.push(`Report Generated: ${new Date().toISOString()}`);
    csvSections.push(`Total Campaigns Analyzed: ${data.summary.totalCampaigns}`);
    csvSections.push(`Total Traffic Sources: ${data.summary.totalSources}`);
    csvSections.push(`Total Revenue Tracked: $${data.summary.totalRevenueTracked.toLocaleString()}`);
    csvSections.push('');

    // Campaign Performance Data
    csvSections.push('CAMPAIGN PERFORMANCE DATA');
    csvSections.push('Campaign Name,Status,Total Raised,Donation Count,Avg Gift,New Donors,Retention Rate,Goal Progress');

    data.campaigns.forEach(campaign => {
      const row = [
        `"${campaign.campaignName}"`,
        campaign.status,
        campaign.currentPeriod.totalRaised,
        campaign.currentPeriod.donationCount,
        campaign.currentPeriod.averageDonation.toFixed(2),
        campaign.currentPeriod.newDonors,
        `${campaign.currentPeriod.retentionRate.toFixed(1)}%`,
        campaign.currentPeriod.goalProgress ? `${campaign.currentPeriod.goalProgress.toFixed(1)}%` : 'N/A'
      ].join(',');

      csvSections.push(row);
    });

    csvSections.push('');

    // Traffic Source Performance Data
    csvSections.push('TRAFFIC SOURCE PERFORMANCE DATA');
    csvSections.push('Source Name,Total Raised,Donation Count,Avg Gift,Conversion Rate,% of Total');

    data.trafficSources.forEach(source => {
      const row = [
        `"${source.displayName}"`,
        source.currentPeriod.totalRaised,
        source.currentPeriod.donationCount,
        source.currentPeriod.averageDonation.toFixed(2),
        `${(source.currentPeriod.conversionRate * 100).toFixed(2)}%`,
        `${source.currentPeriod.percentageOfTotal.toFixed(1)}%`
      ].join(',');

      csvSections.push(row);
    });

    csvSections.push('');

    // Campaign-Source Correlations
    csvSections.push('TOP CAMPAIGN-SOURCE COMBINATIONS');
    csvSections.push('Campaign,Source,Total Raised,Donations,Conversion Rate,Performance Index');

    data.correlations.slice(0, 10).forEach(correlation => {
      const row = [
        `"${correlation.campaignName}"`,
        `"${getDisplayName(correlation.sourceName)}"`,
        correlation.totalRaised,
        correlation.donationCount,
        `${(correlation.conversionRate * 100).toFixed(2)}%`,
        correlation.performanceIndex.toFixed(1)
      ].join(',');

      csvSections.push(row);
    });

    csvSections.push('');

    // Strategic Recommendations
    csvSections.push('STRATEGIC RECOMMENDATIONS');
    csvSections.push('Priority,Type,Title,Description,Expected Impact');

    data.recommendations.forEach(rec => {
      const row = [
        rec.priority.toUpperCase(),
        rec.type.charAt(0).toUpperCase() + rec.type.slice(1),
        `"${rec.title}"`,
        `"${rec.description}"`,
        rec.expectedImpact.charAt(0).toUpperCase() + rec.expectedImpact.slice(1)
      ].join(',');

      csvSections.push(row);
    });

    // Download CSV
    const csvContent = csvSections.join('\n');
    const blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' });
    const link = document.createElement('a');

    if (link.download !== undefined) {
      const url = URL.createObjectURL(blob);
      link.setAttribute('href', url);
      link.setAttribute('download', `campaign-intelligence-report-${new Date().toISOString().split('T')[0]}.csv`);
      link.style.visibility = 'hidden';
      document.body.appendChild(link);
      link.click();
      document.body.removeChild(link);
    }
  }

  /**
   * Export campaign intelligence insights as formatted JSON
   */
  static exportToJson(data: CampaignIntelligenceExportData): void {
    const exportData = {
      metadata: {
        reportType: 'Campaign Intelligence Analysis',
        generatedAt: new Date().toISOString(),
        dataRange: {
          // Would include actual date range from filters
        }
      },
      summary: data.summary,
      campaignPerformance: data.campaigns,
      trafficSourcePerformance: data.trafficSources,
      topCombinations: data.correlations.slice(0, 10),
      strategicRecommendations: data.recommendations
    };

    const jsonContent = JSON.stringify(exportData, null, 2);
    const blob = new Blob([jsonContent], { type: 'application/json;charset=utf-8;' });
    const link = document.createElement('a');

    if (link.download !== undefined) {
      const url = URL.createObjectURL(blob);
      link.setAttribute('href', url);
      link.setAttribute('download', `campaign-intelligence-data-${new Date().toISOString().split('T')[0]}.json`);
      link.style.visibility = 'hidden';
      document.body.appendChild(link);
      link.click();
      document.body.removeChild(link);
    }
  }
}
```

### File Locations and Naming Conventions
**Integration Component Files:**
- `apps/web/components/analytics/CampaignIntelligenceSection.tsx` - Main integration container
- `apps/web/components/analytics/CampaignIntelligenceSummary.tsx` - Cross-chart insights display
- `apps/web/components/analytics/CampaignIntelligenceExport.tsx` - Export functionality
- `apps/web/components/error/CampaignIntelligenceErrorBoundary.tsx` - Error handling

**Analysis and Performance Files:**
- `apps/web/lib/analytics/CampaignIntelligenceAnalyzer.ts` - Cross-chart analysis utilities
- `apps/web/lib/performance/CampaignIntelligencePerformanceMonitor.ts` - Performance tracking
- `apps/web/hooks/useCampaignIntelligenceData.ts` - Unified data fetching hook
- `apps/web/lib/export/CampaignIntelligenceExporter.ts` - Export functionality

**Query Collaboration Files:**
- `docs/campaign-intelligence-query-collaboration.md` - Collaboration guidelines
- `apps/web/lib/queries/CampaignIntelligenceQueryTemplates.ts` - Combined query templates
- `apps/web/lib/optimization/CampaignIntelligenceQueryOptimizer.ts` - Agent optimization utilities

### Query Collaboration Integration
**Combined Campaign Intelligence Query System:**
```typescript
const campaignIntelligenceQueryRequest: CombinedQueryCollaborationRequest = {
  analysisType: 'campaign-intelligence',
  requiredCharts: ['campaign-performance', 'traffic-source'],
  crossAnalysisNeeds: {
    campaignSourceCorrelation: true,
    attributionFlow: true,
    strategicRecommendations: true
  },
  sharedFiltering: {
    dateRange: true,
    appeals: true,
    funds: true,
    frequency: true
  },
  performanceRequirements: {
    maxTotalExecutionTime: '2500ms',
    maxIndividualQueryTime: '1200ms',
    cacheStrategy: 'aggressive',
    parallellization: true
  },
  dataConsistency: {
    campaignSourceMapping: 'required',
    dateAlignment: 'strict',
    metricsCalculation: 'consistent'
  },
  collaborationWorkflow: [
    '1. User provides campaign performance query (from Story 3.1)',
    '2. User provides traffic source attribution query (from Story 3.2)',
    '3. Agent validates data consistency between queries',
    '4. Agent optimizes for cross-chart analysis performance',
    '5. Agent implements correlation analysis logic',
    '6. Validation cycle for integrated campaign intelligence accuracy'
  ]
};
```

## Testing

### Testing Standards [Source: docs/architecture.md#technology-stack-table]
**Testing Framework:** Jest + React Testing Library for component testing, Playwright for E2E integration testing
**Test File Location:** `__tests__/` directories alongside campaign intelligence components
**Testing Patterns:**
- Integration testing for unified data fetching and cross-chart analysis
- Performance testing for campaign intelligence section load times
- Query collaboration testing with mock user-provided queries
- Export functionality testing with comprehensive data validation

**Specific Testing Requirements for This Story:**
- Unified data fetching performance and parallel API call optimization
- Cross-chart insights accuracy and correlation analysis calculations
- Query collaboration system testing with combined campaign and traffic source queries
- Performance monitoring and optimization ensuring sub-3-second load times
- Shared comparison period synchronization across campaign intelligence visualizations
- Export functionality testing for comprehensive campaign intelligence reports
- Error handling and loading state coordination across integrated components

**Test Files to Create:**
- `apps/web/components/analytics/__tests__/CampaignIntelligenceSection.test.tsx` - Integration tests
- `apps/web/lib/analytics/__tests__/CampaignIntelligenceAnalyzer.test.ts` - Cross-analysis tests
- `apps/web/hooks/__tests__/useCampaignIntelligenceData.test.ts` - Data fetching hook tests
- `apps/web/lib/export/__tests__/CampaignIntelligenceExporter.test.ts` - Export functionality tests
- `apps/web/__tests__/performance/campaign-intelligence-performance.test.ts` - E2E performance tests

## Change Log

| Date | Version | Description | Author |
|------|---------|-------------|---------|
| 2025-09-26 | 1.0 | Initial story creation completing Phase 1 Campaign Intelligence epic with comprehensive integration and performance optimization | Claude (Story Agent) |

## Dev Agent Record

*This section will be populated by the development agent during implementation*

### Agent Model Used
*To be filled by dev agent*

### Debug Log References
*To be filled by dev agent*

### Completion Notes List
*To be filled by dev agent*

### File List
*To be filled by dev agent*

## QA Results

*Results from QA Agent review will be populated here*